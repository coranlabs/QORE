/*
 * Nnwdaf_EventsSubscription
 *
 * Nnwdaf_EventsSubscription Service API.   Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved.
 *
 * API version: 1.2.0-alpha.7
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package events

// EventSubscription - Represents a subscription to a single event.
type EventSubscription struct {

	// FALSE represents not applicable for all slices. TRUE represents applicable for all slices.
	AnySlice bool `json:"anySlice,omitempty"`

	// Identification(s) of application to which the subscription applies.
	AppIds []string `json:"appIds,omitempty"`

	// Identification(s) of DNN to which the subscription applies.
	Dnns []string `json:"dnns,omitempty"`

	Dnais []string `json:"dnais,omitempty"`

	Event NwdafEvent `json:"event"`

	ExtraReportReq EventReportingRequirement `json:"extraReportReq,omitempty"`

	// Identification(s) of LADN DNN to indicate the LADN service area as the AOI.
	LadnDnns []string `json:"ladnDnns,omitempty"`

	// Indicates that the NWDAF shall report the corresponding network slice load level to the NF service consumer where the load level of the network slice identified by snssais is reached.
	LoadLevelThreshold int32 `json:"loadLevelThreshold,omitempty"`

	NotificationMethod NotificationMethod `json:"notificationMethod,omitempty"`

	MatchingDir MatchingDirection `json:"matchingDir,omitempty"`

	// Shall be supplied in order to start reporting when an average load level is reached.
	NfLoadLvlThds []ThresholdLevel `json:"nfLoadLvlThds,omitempty"`

	NfInstanceIds []string `json:"nfInstanceIds,omitempty"`

	NfSetIds []string `json:"nfSetIds,omitempty"`

	NfTypes []NfType `json:"nfTypes,omitempty"`

	NetworkArea NetworkAreaInfo `json:"networkArea,omitempty"`

	VisitedAreas []NetworkAreaInfo `json:"visitedAreas,omitempty"`

	// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
	MaxTopAppUlNbr int32 `json:"maxTopAppUlNbr,omitempty"`

	// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
	MaxTopAppDlNbr int32 `json:"maxTopAppDlNbr,omitempty"`

	NsiIdInfos []NsiIdInfo `json:"nsiIdInfos,omitempty"`

	NsiLevelThrds []int32 `json:"nsiLevelThrds,omitempty"`

	QosRequ QosRequirement `json:"qosRequ,omitempty"`

	QosFlowRetThds []RetainabilityThreshold `json:"qosFlowRetThds,omitempty"`

	RanUeThrouThds []string `json:"ranUeThrouThds,omitempty"`

	// indicating a time in seconds.
	RepetitionPeriod int32 `json:"repetitionPeriod,omitempty"`

	// Identification(s) of network slice to which the subscription applies. It corresponds to snssais in the data model definition of 3GPP TS 29.520.
	Snssaia []Snssai `json:"snssaia,omitempty"`

	TgtUe TargetUeInformation `json:"tgtUe,omitempty"`

	CongThresholds []ThresholdLevel `json:"congThresholds,omitempty"`

	NwPerfRequs []NetworkPerfRequirement `json:"nwPerfRequs,omitempty"`

	BwRequs []BwRequirement `json:"bwRequs,omitempty"`

	ExcepRequs []Exception `json:"excepRequs,omitempty"`

	ExptAnaType ExpectedAnalyticsType `json:"exptAnaType,omitempty"`

	ExptUeBehav ExpectedUeBehaviourData `json:"exptUeBehav,omitempty"`

	RatTypes []RatType `json:"ratTypes,omitempty"`

	Freqs []int32 `json:"freqs,omitempty"`

	ListOfAnaSubsets []AnalyticsSubset `json:"listOfAnaSubsets,omitempty"`

	DisperReqs []DispersionRequirement `json:"disperReqs,omitempty"`

	RedTransReqs []RedundantTransmissionExpReq `json:"redTransReqs,omitempty"`

	WlanReqs []WlanPerformanceReq `json:"wlanReqs,omitempty"`

	// Identifies the UPF.
	UpfId string `json:"upfId,omitempty"`

	AppServerAddrs []AddrFqdn `json:"appServerAddrs,omitempty"`

	DnPerfReqs []DnPerformanceReq `json:"dnPerfReqs,omitempty"`
}

// AssertEventSubscriptionRequired checks if the required fields are not zero-ed
func AssertEventSubscriptionRequired(obj EventSubscription) error {
	elements := map[string]interface{}{
		"event": obj.Event,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertNwdafEventRequired(obj.Event); err != nil {
		return err
	}
	if err := AssertEventReportingRequirementRequired(obj.ExtraReportReq); err != nil {
		return err
	}
	if err := AssertNotificationMethodRequired(obj.NotificationMethod); err != nil {
		return err
	}
	if err := AssertMatchingDirectionRequired(obj.MatchingDir); err != nil {
		return err
	}
	for _, el := range obj.NfLoadLvlThds {
		if err := AssertThresholdLevelRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.NfTypes {
		if err := AssertNfTypeRequired(el); err != nil {
			return err
		}
	}
	if err := AssertNetworkAreaInfoRequired(obj.NetworkArea); err != nil {
		return err
	}
	for _, el := range obj.VisitedAreas {
		if err := AssertNetworkAreaInfoRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.NsiIdInfos {
		if err := AssertNsiIdInfoRequired(el); err != nil {
			return err
		}
	}
	if err := AssertQosRequirementRequired(obj.QosRequ); err != nil {
		return err
	}
	for _, el := range obj.QosFlowRetThds {
		if err := AssertRetainabilityThresholdRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Snssaia {
		if err := AssertSnssaiRequired(el); err != nil {
			return err
		}
	}
	if err := AssertTargetUeInformationRequired(obj.TgtUe); err != nil {
		return err
	}
	for _, el := range obj.CongThresholds {
		if err := AssertThresholdLevelRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.NwPerfRequs {
		if err := AssertNetworkPerfRequirementRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.BwRequs {
		if err := AssertBwRequirementRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ExcepRequs {
		if err := AssertExceptionRequired(el); err != nil {
			return err
		}
	}
	if err := AssertExpectedAnalyticsTypeRequired(obj.ExptAnaType); err != nil {
		return err
	}
	if err := AssertExpectedUeBehaviourDataRequired(obj.ExptUeBehav); err != nil {
		return err
	}
	for _, el := range obj.RatTypes {
		if err := AssertRatTypeRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ListOfAnaSubsets {
		if err := AssertAnalyticsSubsetRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.DisperReqs {
		if err := AssertDispersionRequirementRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.RedTransReqs {
		if err := AssertRedundantTransmissionExpReqRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.WlanReqs {
		if err := AssertWlanPerformanceReqRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.AppServerAddrs {
		if err := AssertAddrFqdnRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.DnPerfReqs {
		if err := AssertDnPerformanceReqRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertRecurseEventSubscriptionRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of EventSubscription (e.g. [][]EventSubscription), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseEventSubscriptionRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aEventSubscription, ok := obj.(EventSubscription)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertEventSubscriptionRequired(aEventSubscription)
	})
}
