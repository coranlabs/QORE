diff --git a/include/encap.h b/include/encap.h
index 31083d1..016e660 100644
--- a/include/encap.h
+++ b/include/encap.h
@@ -10,7 +10,8 @@
 #define PKT_FORWARDED 0
 #define PKT_DROPPED -1
 
-enum gtp5g_msg_type_attrs {
+enum gtp5g_msg_type_attrs
+{
     GTP5G_BUFFER = 1,
     GTP5G_REPORT,
 
@@ -18,7 +19,8 @@ enum gtp5g_msg_type_attrs {
 };
 #define GTP5G_MSG_TYPE_ATTR_MAX (__GTP5G_MSG_TYPE_ATTR_MAX - 1);
 
-enum gtp5g_buffer_attrs {
+enum gtp5g_buffer_attrs
+{
     /* gtp5g_device_attrs in this part */
 
     GTP5G_BUFFER_PAD = 3,
@@ -36,9 +38,9 @@ enum gtp5g_buffer_attrs {
 };
 #define GTP5G_BUFFER_ATTR_MAX (__GTP5G_BUFFER_ATTR_MAX - 1)
 
-extern struct sock *gtp5g_encap_enable(int, int, struct gtp5g_dev *);
+extern struct sock *up3_create(int, int, struct gtp5g_dev *);
 extern void gtp5g_encap_disable(struct sock *);
 extern int gtp5g_handle_skb_ipv4(struct sk_buff *, struct net_device *,
-        struct gtp5g_pktinfo *);
+                                 struct gtp5g_pktinfo *);
 
 #endif // __ENCAP_H__
\ No newline at end of file
diff --git a/include/log.h b/include/log.h
index 596d19d..738034e 100644
--- a/include/log.h
+++ b/include/log.h
@@ -6,9 +6,9 @@
 #define DBG(level, dev, fmt, args...) do {      \
     if (level <= get_dbg_lvl()) {               \
         if (dev)                                \
-            printk_ratelimited("%s:[gtp5g] %s: "fmt, netdev_name(dev), __func__, ##args);   \
+            printk_ratelimited("%s:[up3] %s: "fmt, netdev_name(dev), __func__, ##args);   \
         else                                    \
-            printk_ratelimited("[gtp5g] %s: " fmt, __func__, ##args);       \
+            printk_ratelimited("[up3] %s: " fmt, __func__, ##args);       \
     } \
 } while(0)
 
diff --git a/src/genl/genl_qer.c b/src/genl/genl_qer.c
index a8129c0..65bf1f9 100644
--- a/src/genl/genl_qer.c
+++ b/src/genl/genl_qer.c
@@ -39,60 +39,74 @@ int gtp5g_genl_add_qer(struct sk_buff *skb, struct genl_info *info)
     rcu_read_lock();
 
     gtp = gtp5g_find_dev(sock_net(skb->sk), ifindex, netnsfd);
-    if (!gtp) {
+    if (!gtp)
+    {
         rcu_read_unlock();
         rtnl_unlock();
         return -ENODEV;
     }
 
-    if (info->attrs[GTP5G_QER_SEID]) {
+    if (info->attrs[GTP5G_QER_SEID])
+    {
         seid = nla_get_u64(info->attrs[GTP5G_QER_SEID]);
-    } else {
+    }
+    else
+    {
         seid = 0;
     }
 
-    if (info->attrs[GTP5G_QER_ID]) {
+    if (info->attrs[GTP5G_QER_ID])
+    {
         qer_id = nla_get_u32(info->attrs[GTP5G_QER_ID]);
-    } else {
+    }
+    else
+    {
         rcu_read_unlock();
         rtnl_unlock();
         return -ENODEV;
     }
 
     qer = find_qer_by_id(gtp, seid, qer_id);
-    if (qer) {
-        if (info->nlhdr->nlmsg_flags & NLM_F_EXCL) {
+    if (qer)
+    {
+        if (info->nlhdr->nlmsg_flags & NLM_F_EXCL)
+        {
             rcu_read_unlock();
             rtnl_unlock();
             return -EEXIST;
         }
-        if (!(info->nlhdr->nlmsg_flags & NLM_F_REPLACE)) {
+        if (!(info->nlhdr->nlmsg_flags & NLM_F_REPLACE))
+        {
             rcu_read_unlock();
             rtnl_unlock();
             return -EOPNOTSUPP;
         }
         err = qer_fill(qer, gtp, info);
-        if (err) {
+        if (err)
+        {
             qer_context_delete(qer);
             return err;
         }
         return 0;
     }
 
-    if (info->nlhdr->nlmsg_flags & NLM_F_REPLACE) {
+    if (info->nlhdr->nlmsg_flags & NLM_F_REPLACE)
+    {
         rcu_read_unlock();
         rtnl_unlock();
         return -ENOENT;
     }
 
-    if (info->nlhdr->nlmsg_flags & NLM_F_APPEND) {
+    if (info->nlhdr->nlmsg_flags & NLM_F_APPEND)
+    {
         rcu_read_unlock();
         rtnl_unlock();
         return -EOPNOTSUPP;
     }
 
     qer = kzalloc(sizeof(*qer), GFP_ATOMIC);
-    if (!qer) {
+    if (!qer)
+    {
         rcu_read_unlock();
         rtnl_unlock();
         return -ENOMEM;
@@ -101,7 +115,8 @@ int gtp5g_genl_add_qer(struct sk_buff *skb, struct genl_info *info)
     qer->dev = gtp->dev;
 
     err = qer_fill(qer, gtp, info);
-    if (err) {
+    if (err)
+    {
         qer_context_delete(qer);
         rcu_read_unlock();
         rtnl_unlock();
@@ -136,31 +151,39 @@ int gtp5g_genl_del_qer(struct sk_buff *skb, struct genl_info *info)
     rcu_read_lock();
 
     gtp = gtp5g_find_dev(sock_net(skb->sk), ifindex, netnsfd);
-    if (!gtp) {
+    if (!gtp)
+    {
         rcu_read_unlock();
         return -ENODEV;
     }
 
-    if (info->attrs[GTP5G_QER_SEID]) {
+    if (info->attrs[GTP5G_QER_SEID])
+    {
         seid = nla_get_u64(info->attrs[GTP5G_QER_SEID]);
-    } else {
+    }
+    else
+    {
         seid = 0;
     }
 
-    if (info->attrs[GTP5G_QER_ID]) {
+    if (info->attrs[GTP5G_QER_ID])
+    {
         qer_id = nla_get_u32(info->attrs[GTP5G_QER_ID]);
-    } else {
+    }
+    else
+    {
         rcu_read_unlock();
         return -ENODEV;
     }
 
     qer = find_qer_by_id(gtp, seid, qer_id);
-    if (!qer) {
+    if (!qer)
+    {
         rcu_read_unlock();
         return -ENOENT;
     }
 
-    // free QoS traffic policer 
+    // free QoS traffic policer
     kfree(qer->ul_policer);
     qer->ul_policer = NULL;
     kfree(qer->dl_policer);
@@ -197,42 +220,52 @@ int gtp5g_genl_get_qer(struct sk_buff *skb, struct genl_info *info)
     rcu_read_lock();
 
     gtp = gtp5g_find_dev(sock_net(skb->sk), ifindex, netnsfd);
-    if (!gtp) {
+    if (!gtp)
+    {
         rcu_read_unlock();
         return -ENODEV;
     }
 
-    if (info->attrs[GTP5G_QER_SEID]) {
+    if (info->attrs[GTP5G_QER_SEID])
+    {
         seid = nla_get_u64(info->attrs[GTP5G_QER_SEID]);
-    } else {
+    }
+    else
+    {
         seid = 0;
     }
 
-    if (info->attrs[GTP5G_QER_ID]) {
+    if (info->attrs[GTP5G_QER_ID])
+    {
         qer_id = nla_get_u32(info->attrs[GTP5G_QER_ID]);
-    } else {
+    }
+    else
+    {
         rcu_read_unlock();
         return -ENODEV;
     }
 
     qer = find_qer_by_id(gtp, seid, qer_id);
-    if (!qer) {
+    if (!qer)
+    {
         rcu_read_unlock();
         return -ENOENT;
     }
 
     skb_ack = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
-    if (!skb_ack) {
+    if (!skb_ack)
+    {
         rcu_read_unlock();
         return -ENOMEM;
     }
 
     err = gtp5g_genl_fill_qer(skb_ack,
-            NETLINK_CB(skb).portid,
-            info->snd_seq,
-            info->nlhdr->nlmsg_type,
-            qer);
-    if (err) {
+                              NETLINK_CB(skb).portid,
+                              info->snd_seq,
+                              info->nlhdr->nlmsg_type,
+                              qer);
+    if (err)
+    {
         kfree_skb(skb_ack);
         rcu_read_unlock();
         return err;
@@ -263,23 +296,27 @@ int gtp5g_genl_dump_qer(struct sk_buff *skb, struct netlink_callback *cb)
     if (cb->args[5])
         return 0;
 
-    list_for_each_entry_rcu(gtp, &gn->gtp5g_dev_list, list) {
+    list_for_each_entry_rcu(gtp, &gn->gtp5g_dev_list, list)
+    {
         if (last_gtp && last_gtp != gtp)
             continue;
         else
             last_gtp = NULL;
 
-        for (i = last_hash_entry_id; i < gtp->hash_size; i++) {
-            hlist_for_each_entry_rcu(qer, &gtp->qer_id_hash[i], hlist_id) {
+        for (i = last_hash_entry_id; i < gtp->hash_size; i++)
+        {
+            hlist_for_each_entry_rcu(qer, &gtp->qer_id_hash[i], hlist_id)
+            {
                 if (qer_id && qer_id != qer->id)
                     continue;
                 qer_id = 0;
                 ret = gtp5g_genl_fill_qer(skb,
-                        NETLINK_CB(cb->skb).portid,
-                        cb->nlh->nlmsg_seq,
-                        cb->nlh->nlmsg_type,
-                        qer);
-                if (ret) {
+                                          NETLINK_CB(cb->skb).portid,
+                                          cb->nlh->nlmsg_seq,
+                                          cb->nlh->nlmsg_type,
+                                          qer);
+                if (ret)
+                {
                     cb->args[0] = (unsigned long)gtp;
                     cb->args[1] = i;
                     cb->args[2] = qer->id;
@@ -294,7 +331,8 @@ out:
     return skb->len;
 }
 
-u64 concat_bit_rate(u32 highbit, u8 lowbit) {
+u64 concat_bit_rate(u32 highbit, u8 lowbit)
+{
     return (highbit << 8) | lowbit;
 }
 
@@ -310,18 +348,20 @@ static int qer_fill(struct qer *qer, struct gtp5g_dev *gtp, struct genl_info *in
     else
         qer->seid = 0;
 
-    if (info->attrs[GTP5G_QER_GATE]) {
+    if (info->attrs[GTP5G_QER_GATE])
+    {
         qer->ul_dl_gate = nla_get_u8(info->attrs[GTP5G_QER_GATE]);
-        GTP5G_INF(NULL, "QER Gate Status (%x)", qer->ul_dl_gate);
+        GTP5G_TRC(NULL, "QER Gate Status (%x)", qer->ul_dl_gate);
     }
 
     /* MBR */
     if (info->attrs[GTP5G_QER_MBR] &&
-        !nla_parse_nested(mbr_param_attrs, GTP5G_QER_MBR_ATTR_MAX, info->attrs[GTP5G_QER_MBR], NULL, NULL)) {
+        !nla_parse_nested(mbr_param_attrs, GTP5G_QER_MBR_ATTR_MAX, info->attrs[GTP5G_QER_MBR], NULL, NULL))
+    {
         qer->mbr.ul_high = nla_get_u32(mbr_param_attrs[GTP5G_QER_MBR_UL_HIGH32]);
-        qer->mbr.ul_low  = nla_get_u8(mbr_param_attrs[GTP5G_QER_MBR_UL_LOW8]);
+        qer->mbr.ul_low = nla_get_u8(mbr_param_attrs[GTP5G_QER_MBR_UL_LOW8]);
         qer->mbr.dl_high = nla_get_u32(mbr_param_attrs[GTP5G_QER_MBR_DL_HIGH32]);
-        qer->mbr.dl_low  = nla_get_u8(mbr_param_attrs[GTP5G_QER_MBR_DL_LOW8]);
+        qer->mbr.dl_low = nla_get_u8(mbr_param_attrs[GTP5G_QER_MBR_DL_LOW8]);
 
         qer->ul_mbr = concat_bit_rate(qer->mbr.ul_high, qer->mbr.ul_low);
         qer->dl_mbr = concat_bit_rate(qer->mbr.dl_high, qer->mbr.dl_low);
@@ -331,11 +371,12 @@ static int qer_fill(struct qer *qer, struct gtp5g_dev *gtp, struct genl_info *in
 
     /* GBR */
     if (info->attrs[GTP5G_QER_GBR] &&
-        !nla_parse_nested(gbr_param_attrs, GTP5G_QER_GBR_ATTR_MAX, info->attrs[GTP5G_QER_GBR], NULL, NULL)) {
+        !nla_parse_nested(gbr_param_attrs, GTP5G_QER_GBR_ATTR_MAX, info->attrs[GTP5G_QER_GBR], NULL, NULL))
+    {
         qer->gbr.ul_high = nla_get_u32(gbr_param_attrs[GTP5G_QER_GBR_UL_HIGH32]);
-        qer->gbr.ul_low  = nla_get_u8(gbr_param_attrs[GTP5G_QER_GBR_UL_LOW8]);
+        qer->gbr.ul_low = nla_get_u8(gbr_param_attrs[GTP5G_QER_GBR_UL_LOW8]);
         qer->gbr.dl_high = nla_get_u32(gbr_param_attrs[GTP5G_QER_GBR_DL_HIGH32]);
-        qer->gbr.dl_low  = nla_get_u8(gbr_param_attrs[GTP5G_QER_GBR_DL_LOW8]);
+        qer->gbr.dl_low = nla_get_u8(gbr_param_attrs[GTP5G_QER_GBR_DL_LOW8]);
     }
 
     if (info->attrs[GTP5G_QER_CORR_ID])
@@ -358,9 +399,8 @@ static int qer_fill(struct qer *qer, struct gtp5g_dev *gtp, struct genl_info *in
     return 0;
 }
 
-
 static int gtp5g_genl_fill_qer(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
-        u32 type, struct qer *qer)
+                               u32 type, struct qer *qer)
 {
     struct gtp5g_dev *gtp = netdev_priv(qer->dev);
     void *genlh;
@@ -370,7 +410,7 @@ static int gtp5g_genl_fill_qer(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
     int n;
 
     genlh = genlmsg_put(skb, snd_portid, snd_seq,
-            &gtp5g_genl_family, 0, type);
+                        &gtp5g_genl_family, 0, type);
     if (!genlh)
         goto genlmsg_fail;
 
@@ -378,7 +418,8 @@ static int gtp5g_genl_fill_qer(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
         goto genlmsg_fail;
     if (nla_put_u8(skb, GTP5G_QER_GATE, qer->ul_dl_gate))
         goto genlmsg_fail;
-    if (qer->seid) {
+    if (qer->seid)
+    {
         if (nla_put_u64_64bit(skb, GTP5G_QER_SEID, qer->seid, 0))
             goto genlmsg_fail;
     }
@@ -429,7 +470,8 @@ static int gtp5g_genl_fill_qer(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
     if (!ids)
         goto genlmsg_fail;
     n = qer_get_pdr_ids(ids, MAX_PDR_PER_SESSION, qer, gtp);
-    if (n) {
+    if (n)
+    {
         if (nla_put(skb, GTP5G_QER_RELATED_TO_PDR, n * sizeof(u16), ids))
             goto genlmsg_fail;
     }
diff --git a/src/genl/genl_urr.c b/src/genl/genl_urr.c
index 409d269..c7e2c6a 100644
--- a/src/genl/genl_urr.c
+++ b/src/genl/genl_urr.c
@@ -41,35 +41,44 @@ int gtp5g_genl_add_urr(struct sk_buff *skb, struct genl_info *info)
     rcu_read_lock();
 
     gtp = gtp5g_find_dev(sock_net(skb->sk), ifindex, netnsfd);
-    if (!gtp) {
+    if (!gtp)
+    {
         err = -ENODEV;
         goto end;
     }
 
-    if (info->attrs[GTP5G_URR_SEID]) {
+    if (info->attrs[GTP5G_URR_SEID])
+    {
         seid = nla_get_u64(info->attrs[GTP5G_URR_SEID]);
-    } else {
+    }
+    else
+    {
         seid = 0;
     }
 
-    if (!info->attrs[GTP5G_URR_ID]) {
+    if (!info->attrs[GTP5G_URR_ID])
+    {
         err = -ENODEV;
         goto end;
     }
     urr_id = nla_get_u32(info->attrs[GTP5G_URR_ID]);
 
     urr = find_urr_by_id(gtp, seid, urr_id);
-    if (urr) {
-        if (info->nlhdr->nlmsg_flags & NLM_F_EXCL) {
+    if (urr)
+    {
+        if (info->nlhdr->nlmsg_flags & NLM_F_EXCL)
+        {
             err = -EEXIST;
             goto end;
         }
-        if (!(info->nlhdr->nlmsg_flags & NLM_F_REPLACE)) {
+        if (!(info->nlhdr->nlmsg_flags & NLM_F_REPLACE))
+        {
             err = -EOPNOTSUPP;
             goto end;
         }
         err = urr_fill(urr, gtp, info);
-        if (err) {
+        if (err)
+        {
             urr_context_delete(urr);
             goto end;
         }
@@ -77,18 +86,21 @@ int gtp5g_genl_add_urr(struct sk_buff *skb, struct genl_info *info)
         goto end;
     }
 
-    if (info->nlhdr->nlmsg_flags & NLM_F_REPLACE) {
+    if (info->nlhdr->nlmsg_flags & NLM_F_REPLACE)
+    {
         err = -ENOENT;
         goto end;
     }
 
-    if (info->nlhdr->nlmsg_flags & NLM_F_APPEND) {
+    if (info->nlhdr->nlmsg_flags & NLM_F_APPEND)
+    {
         err = -EOPNOTSUPP;
         goto end;
     }
 
     urr = kzalloc(sizeof(*urr), GFP_ATOMIC);
-    if (!urr) {
+    if (!urr)
+    {
         err = -ENOMEM;
         goto end;
     }
@@ -97,7 +109,8 @@ int gtp5g_genl_add_urr(struct sk_buff *skb, struct genl_info *info)
     urr->start_time = ktime_get_real();
 
     err = urr_fill(urr, gtp, info);
-    if (err) {
+    if (err)
+    {
         urr_context_delete(urr);
         goto end;
     }
@@ -134,37 +147,45 @@ int gtp5g_genl_del_urr(struct sk_buff *skb, struct genl_info *info)
     rcu_read_lock();
 
     gtp = gtp5g_find_dev(sock_net(skb->sk), ifindex, netnsfd);
-    if (!gtp) {
+    if (!gtp)
+    {
         err = -ENODEV;
         goto fail;
     }
 
-    if (info->attrs[GTP5G_URR_SEID]) {
+    if (info->attrs[GTP5G_URR_SEID])
+    {
         seid = nla_get_u64(info->attrs[GTP5G_URR_SEID]);
-    } else {
+    }
+    else
+    {
         seid = 0;
     }
 
-    if (!info->attrs[GTP5G_URR_ID]) {
+    if (!info->attrs[GTP5G_URR_ID])
+    {
         err = -ENODEV;
         goto fail;
     }
     urr_id = nla_get_u32(info->attrs[GTP5G_URR_ID]);
 
     urr = find_urr_by_id(gtp, seid, urr_id);
-    if (!urr) {
+    if (!urr)
+    {
         err = -ENOENT;
         goto fail;
     }
 
     skb_ack = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
-    if (!skb_ack) {
+    if (!skb_ack)
+    {
         err = -ENOMEM;
         goto fail;
     }
 
     report = kzalloc(sizeof(struct usage_report), GFP_KERNEL);
-    if (!report) {
+    if (!report)
+    {
         err = -ENOMEM;
         goto fail;
     }
@@ -172,16 +193,18 @@ int gtp5g_genl_del_urr(struct sk_buff *skb, struct genl_info *info)
     convert_urr_to_report(urr, report);
 
     err = gtp5g_genl_fill_usage_report(skb_ack,
-            NETLINK_CB(skb).portid,
-            info->snd_seq,
-            info->nlhdr->nlmsg_type,
-            report);
+                                       NETLINK_CB(skb).portid,
+                                       info->snd_seq,
+                                       info->nlhdr->nlmsg_type,
+                                       report);
 
     kfree(report);
 
 fail:
-    if (err) {
-        if (skb_ack) {
+    if (err)
+    {
+        if (skb_ack)
+        {
             kfree_skb(skb_ack);
         }
         rcu_read_unlock();
@@ -216,44 +239,53 @@ int gtp5g_genl_get_urr(struct sk_buff *skb, struct genl_info *info)
     rcu_read_lock();
 
     gtp = gtp5g_find_dev(sock_net(skb->sk), ifindex, netnsfd);
-    if (!gtp) {
+    if (!gtp)
+    {
         err = -ENODEV;
         goto fail;
     }
 
-    if (info->attrs[GTP5G_URR_SEID]) {
+    if (info->attrs[GTP5G_URR_SEID])
+    {
         seid = nla_get_u64(info->attrs[GTP5G_URR_SEID]);
-    } else {
+    }
+    else
+    {
         seid = 0;
     }
 
-    if (!info->attrs[GTP5G_URR_ID]) {
+    if (!info->attrs[GTP5G_URR_ID])
+    {
         err = -ENODEV;
         goto fail;
     }
     urr_id = nla_get_u32(info->attrs[GTP5G_URR_ID]);
 
     urr = find_urr_by_id(gtp, seid, urr_id);
-    if (!urr) {
+    if (!urr)
+    {
         err = -ENOENT;
         goto fail;
     }
 
     skb_ack = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
-    if (!skb_ack) {
+    if (!skb_ack)
+    {
         err = -ENOMEM;
         goto fail;
     }
 
     err = gtp5g_genl_fill_urr(skb_ack,
-            NETLINK_CB(skb).portid,
-            info->snd_seq,
-            info->nlhdr->nlmsg_type,
-            urr);
+                              NETLINK_CB(skb).portid,
+                              info->snd_seq,
+                              info->nlhdr->nlmsg_type,
+                              urr);
 
 fail:
-    if (err) {
-        if (skb_ack) {
+    if (err)
+    {
+        if (skb_ack)
+        {
             kfree_skb(skb_ack);
         }
         rcu_read_unlock();
@@ -261,7 +293,7 @@ fail:
     }
 
     rcu_read_unlock();
-    return genlmsg_unicast(genl_info_net(info), skb_ack, info->snd_portid); 
+    return genlmsg_unicast(genl_info_net(info), skb_ack, info->snd_portid);
 }
 
 int gtp5g_genl_dump_urr(struct sk_buff *skb, struct netlink_callback *cb)
@@ -285,23 +317,27 @@ int gtp5g_genl_dump_urr(struct sk_buff *skb, struct netlink_callback *cb)
     if (cb->args[5])
         return 0;
 
-    list_for_each_entry_rcu(gtp, &gn->gtp5g_dev_list, list) {
+    list_for_each_entry_rcu(gtp, &gn->gtp5g_dev_list, list)
+    {
         if (last_gtp && last_gtp != gtp)
             continue;
         else
             last_gtp = NULL;
 
-        for (i = last_hash_entry_id; i < gtp->hash_size; i++) {
-            hlist_for_each_entry_rcu(urr, &gtp->urr_id_hash[i], hlist_id) {
+        for (i = last_hash_entry_id; i < gtp->hash_size; i++)
+        {
+            hlist_for_each_entry_rcu(urr, &gtp->urr_id_hash[i], hlist_id)
+            {
                 if (urr_id && urr_id != urr->id)
                     continue;
                 urr_id = 0;
                 ret = gtp5g_genl_fill_urr(skb,
-                        NETLINK_CB(cb->skb).portid,
-                        cb->nlh->nlmsg_seq,
-                        cb->nlh->nlmsg_type,
-                        urr);
-                if (ret) {
+                                          NETLINK_CB(cb->skb).portid,
+                                          cb->nlh->nlmsg_seq,
+                                          cb->nlh->nlmsg_type,
+                                          urr);
+                if (ret)
+                {
                     cb->args[0] = (unsigned long)gtp;
                     cb->args[1] = i;
                     cb->args[2] = urr->id;
@@ -316,7 +352,6 @@ out:
     return skb->len;
 }
 
-
 static int urr_fill(struct urr *urr, struct gtp5g_dev *gtp, struct genl_info *info)
 {
     urr->id = nla_get_u32(info->attrs[GTP5G_URR_ID]);
@@ -329,9 +364,11 @@ static int urr_fill(struct urr *urr, struct gtp5g_dev *gtp, struct genl_info *in
     if (info->attrs[GTP5G_URR_MEASUREMENT_METHOD])
         urr->method = nla_get_u8(info->attrs[GTP5G_URR_MEASUREMENT_METHOD]);
 
-    if (info->attrs[GTP5G_URR_REPORTING_TRIGGER]) {
+    if (info->attrs[GTP5G_URR_REPORTING_TRIGGER])
+    {
         urr->trigger = nla_get_u32(info->attrs[GTP5G_URR_REPORTING_TRIGGER]);
-        if (urr->trigger == URR_RPT_TRIGGER_START) {
+        if (urr->trigger == URR_RPT_TRIGGER_START)
+        {
             // Clean bytes to make sure the bytes are counted after the start of service data flow
             // TODO: Should send the previous stroed bytes to CP first
             memset(&urr->bytes, 0, sizeof(struct VolumeMeasurement));
@@ -347,16 +384,20 @@ static int urr_fill(struct urr *urr, struct gtp5g_dev *gtp, struct genl_info *in
     if (info->attrs[GTP5G_URR_VOLUME_THRESHOLD])
         parse_volumethreshold(urr, info->attrs[GTP5G_URR_VOLUME_THRESHOLD]);
 
-    if (info->attrs[GTP5G_URR_VOLUME_QUOTA]) {
+    if (info->attrs[GTP5G_URR_VOLUME_QUOTA])
+    {
         parse_volumeqouta(urr, info->attrs[GTP5G_URR_VOLUME_QUOTA]);
         urr->consumed = urr->bytes;
 
-        if (urr->volumequota.totalVolume == 0 && urr->trigger == URR_RPT_TRIGGER_VOLQU) {
+        if (urr->volumequota.totalVolume == 0 && urr->trigger == URR_RPT_TRIGGER_VOLQU)
+        {
             urr_quota_exhaust_action(urr, gtp);
-            GTP5G_INF(NULL, "URR (%u) Receive zero quota, stop measure", urr->id);
-        } else if (urr->quota_exhausted) {
+            GTP5G_TRC(NULL, "URR (%u) Receive zero quota, stop measure", urr->id);
+        }
+        else if (urr->quota_exhausted)
+        {
             urr_reverse_quota_exhaust_action(urr, gtp);
-            GTP5G_INF(NULL, "URR (%u) Receive New quota, continue measure", urr->id);
+            GTP5G_TRC(NULL, "URR (%u) Receive New quota, continue measure", urr->id);
         }
     }
 
@@ -375,19 +416,23 @@ static int parse_volumethreshold(struct urr *urr, struct nlattr *a)
     if (err)
         return err;
 
-    if (attrs[GTP5G_URR_VOLUME_THRESHOLD_FLAG]) {
+    if (attrs[GTP5G_URR_VOLUME_THRESHOLD_FLAG])
+    {
         urr->volumethreshold.flag = nla_get_u8(attrs[GTP5G_URR_VOLUME_THRESHOLD_FLAG]);
     }
 
-    if (attrs[GTP5G_URR_VOLUME_THRESHOLD_TOVOL]) {
+    if (attrs[GTP5G_URR_VOLUME_THRESHOLD_TOVOL])
+    {
         urr->volumethreshold.totalVolume = nla_get_u64(attrs[GTP5G_URR_VOLUME_THRESHOLD_TOVOL]);
     }
 
-    if (attrs[GTP5G_URR_VOLUME_THRESHOLD_UVOL]) {
+    if (attrs[GTP5G_URR_VOLUME_THRESHOLD_UVOL])
+    {
         urr->volumethreshold.uplinkVolume = nla_get_u64(attrs[GTP5G_URR_VOLUME_THRESHOLD_UVOL]);
     }
 
-    if (attrs[GTP5G_URR_VOLUME_THRESHOLD_DVOL]) {
+    if (attrs[GTP5G_URR_VOLUME_THRESHOLD_DVOL])
+    {
         urr->volumethreshold.downlinkVolume = nla_get_u64(attrs[GTP5G_URR_VOLUME_THRESHOLD_DVOL]);
     }
 
@@ -403,19 +448,23 @@ static int parse_volumeqouta(struct urr *urr, struct nlattr *a)
     if (err)
         return err;
 
-    if (attrs[GTP5G_URR_VOLUME_QUOTA_FLAG]) {
+    if (attrs[GTP5G_URR_VOLUME_QUOTA_FLAG])
+    {
         urr->volumequota.flag = nla_get_u8(attrs[GTP5G_URR_VOLUME_QUOTA_FLAG]);
     }
 
-    if (attrs[GTP5G_URR_VOLUME_QUOTA_TOVOL]) {
+    if (attrs[GTP5G_URR_VOLUME_QUOTA_TOVOL])
+    {
         urr->volumequota.totalVolume = nla_get_u64(attrs[GTP5G_URR_VOLUME_QUOTA_TOVOL]);
     }
 
-    if (attrs[GTP5G_URR_VOLUME_QUOTA_UVOL]) {
+    if (attrs[GTP5G_URR_VOLUME_QUOTA_UVOL])
+    {
         urr->volumequota.uplinkVolume = nla_get_u64(attrs[GTP5G_URR_VOLUME_QUOTA_UVOL]);
     }
 
-    if (attrs[GTP5G_URR_VOLUME_QUOTA_DVOL]) {
+    if (attrs[GTP5G_URR_VOLUME_QUOTA_DVOL])
+    {
         urr->volumequota.downlinkVolume = nla_get_u64(attrs[GTP5G_URR_VOLUME_QUOTA_DVOL]);
     }
 
@@ -465,7 +514,7 @@ static int gtp5g_genl_fill_volume_quota(struct sk_buff *skb, struct Volume volum
 }
 
 static int gtp5g_genl_fill_urr(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
-        u32 type, struct urr *urr)
+                               u32 type, struct urr *urr)
 {
     struct gtp5g_dev *gtp = netdev_priv(urr->dev);
     void *genlh;
@@ -473,7 +522,7 @@ static int gtp5g_genl_fill_urr(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
     int n;
 
     genlh = genlmsg_put(skb, snd_portid, snd_seq,
-            &gtp5g_genl_family, 0, type);
+                        &gtp5g_genl_family, 0, type);
     if (!genlh)
         goto genlmsg_fail;
 
@@ -487,16 +536,19 @@ static int gtp5g_genl_fill_urr(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
         goto genlmsg_fail;
     if (nla_put_u8(skb, GTP5G_URR_MEASUREMENT_INFO, urr->info))
         goto genlmsg_fail;
-    if (urr->seid) {
+    if (urr->seid)
+    {
         if (nla_put_u64_64bit(skb, GTP5G_URR_SEID, urr->seid, 0))
             goto genlmsg_fail;
     }
-    if (urr->volumethreshold.flag != 0) {
+    if (urr->volumethreshold.flag != 0)
+    {
         if (gtp5g_genl_fill_volume_threshold(skb, urr->volumethreshold))
             goto genlmsg_fail;
     }
 
-    if (urr->volumequota.flag != 0) {
+    if (urr->volumequota.flag != 0)
+    {
         if (gtp5g_genl_fill_volume_quota(skb, urr->volumequota))
             goto genlmsg_fail;
     }
@@ -504,7 +556,8 @@ static int gtp5g_genl_fill_urr(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
     if (!ids)
         goto genlmsg_fail;
     n = urr_get_pdr_ids(ids, MAX_PDR_PER_SESSION, urr, gtp);
-    if (n) {
+    if (n)
+    {
         if (nla_put(skb, GTP5G_URR_RELATED_TO_PDR, n * sizeof(u16), ids))
             goto genlmsg_fail;
     }
@@ -514,7 +567,8 @@ static int gtp5g_genl_fill_urr(struct sk_buff *skb, u32 snd_portid, u32 snd_seq,
     return 0;
 
 genlmsg_fail:
-    if (ids) {
+    if (ids)
+    {
         kfree(ids);
     }
     genlmsg_cancel(skb, genlh);
diff --git a/src/gtp5g.c b/src/gtp5g.c
index 3d13297..14015f4 100644
--- a/src/gtp5g.c
+++ b/src/gtp5g.c
@@ -8,11 +8,13 @@
 #include "log.h"
 #include "genl_version.h"
 
-static int __init gtp5g_init(void)
+static int __init up3c_init(void)
 {
     int err;
-
-    GTP5G_LOG(NULL, "Gtp5g Module initialization Ver: %s\n", DRV_VERSION);
+    GTP5G_LOG(NULL, "--------------\n");
+    GTP5G_LOG(NULL, "| CORAN UP3C |\n");
+    GTP5G_LOG(NULL, "--------------\n");    
+    GTP5G_LOG(NULL, "UP3C loading into the Stack | Version: CORAN UP3C v1.0");
 
     init_proc_gtp5g_dev_list();
 
@@ -20,28 +22,32 @@ static int __init gtp5g_init(void)
     get_random_bytes(&gtp5g_h_initval, sizeof(gtp5g_h_initval));
 
     err = rtnl_link_register(&gtp5g_link_ops);
-    if (err < 0) {
+    if (err < 0)
+    {
         GTP5G_ERR(NULL, "Failed to register rtnl\n");
         goto error_out;
     }
 
     err = genl_register_family(&gtp5g_genl_family);
-    if (err < 0) {
+    if (err < 0)
+    {
         GTP5G_ERR(NULL, "Failed to register generic\n");
         goto unreg_rtnl_link;
     }
 
     err = register_pernet_subsys(&gtp5g_net_ops);
-    if (err < 0) {
+    if (err < 0)
+    {
         GTP5G_ERR(NULL, "Failed to register namespace\n");
         goto unreg_genl_family;
     }
 
     err = create_proc();
-    if (err < 0) {
+    if (err < 0)
+    {
         goto unreg_pernet;
     }
-    GTP5G_LOG(NULL, "5G GTP module loaded\n");
+    GTP5G_LOG(NULL, "UP3C GTP-U component loaded\n");
 
     return 0;
 unreg_pernet:
@@ -54,19 +60,18 @@ error_out:
     return err;
 }
 
-static void __exit gtp5g_fini(void)
+static void __exit up3c_fini(void)
 {
     genl_unregister_family(&gtp5g_genl_family);
     rtnl_link_unregister(&gtp5g_link_ops);
     unregister_pernet_subsys(&gtp5g_net_ops);
 
     remove_proc();
-
-    GTP5G_LOG(NULL, "5G GTP module unloaded\n");
+    GTP5G_LOG(NULL, "UP3C GTP-U component finished unloading\n");
 }
 
-late_initcall(gtp5g_init);
-module_exit(gtp5g_fini);
+late_initcall(up3c_init);
+module_exit(up3c_fini);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Yao-Wen Chang <yaowenowo@gmail.com>");
diff --git a/src/gtpu/encap.c b/src/gtpu/encap.c
index 6ed32ac..edc496c 100644
--- a/src/gtpu/encap.c
+++ b/src/gtpu/encap.c
@@ -28,7 +28,8 @@
 /* used to compatible with api with/without seid */
 #define MSG_KOV_LEN 4
 
-enum msg_type {
+enum msg_type
+{
     TYPE_BUFFER = 1,
     TYPE_URR_REPORT,
     TYPE_BAR_INFO,
@@ -39,36 +40,40 @@ static int gtp5g_encap_recv(struct sock *, struct sk_buff *);
 static int gtp1u_udp_encap_recv(struct gtp5g_dev *, struct sk_buff *);
 static int gtp5g_rx(struct pdr *, struct sk_buff *, unsigned int, unsigned int);
 static int gtp5g_fwd_skb_encap(struct sk_buff *, struct net_device *,
-        unsigned int, struct pdr *, struct far *);
+                               unsigned int, struct pdr *, struct far *);
 static int netlink_send(struct pdr *, struct far *, struct sk_buff *, struct net *, struct usage_report *, u32);
 static int unix_sock_send(struct pdr *, struct far *, void *, u32, u32);
-static int gtp5g_fwd_skb_ipv4(struct sk_buff *, 
-    struct net_device *, struct gtp5g_pktinfo *, 
-    struct pdr *, struct far *);
+static int gtp5g_fwd_skb_ipv4(struct sk_buff *,
+                              struct net_device *, struct gtp5g_pktinfo *,
+                              struct pdr *, struct far *);
 
 /* When gtp5g newlink, establish the udp tunnel used in N3 interface */
-struct sock *gtp5g_encap_enable(int fd, int type, struct gtp5g_dev *gtp){
+struct sock *up3_create(int fd, int type, struct gtp5g_dev *gtp)
+{
     struct udp_tunnel_sock_cfg tuncfg = {NULL};
     struct socket *sock;
     struct sock *sk;
     int err;
 
-    GTP5G_LOG(NULL, "enable gtp5g for the fd(%d) type(%d)\n", fd, type);
+    GTP5G_TRC(NULL, "enable gtp5g for the fd(%d) type(%d)\n", fd, type);
 
     sock = sockfd_lookup(fd, &err);
-    if (!sock) {
+    if (!sock)
+    {
         GTP5G_ERR(NULL, "Failed to find the socket fd(%d)\n", fd);
         return NULL;
     }
 
-    if (sock->sk->sk_protocol != IPPROTO_UDP) {
+    if (sock->sk->sk_protocol != IPPROTO_UDP)
+    {
         GTP5G_ERR(NULL, "socket fd(%d) is not a UDP\n", fd);
         sk = ERR_PTR(-EINVAL);
         goto out_sock;
     }
 
     lock_sock(sock->sk);
-    if (sock->sk->sk_user_data) {
+    if (sock->sk->sk_user_data)
+    {
         GTP5G_ERR(NULL, "Failed to set sk_user_datat of socket fd(%d)\n", fd);
         sk = ERR_PTR(-EBUSY);
         goto out_sock;
@@ -90,18 +95,19 @@ out_sock:
     return sk;
 }
 
-
 void gtp5g_encap_disable(struct sock *sk)
 {
     struct gtp5g_dev *gtp;
 
-    if (!sk) {
+    if (!sk)
+    {
         return;
     }
 
     lock_sock(sk);
     gtp = sk->sk_user_data;
-    if (gtp) {
+    if (gtp)
+    {
         gtp->sk1u = NULL;
         udp_sk(sk)->encap_type = 0;
         // sk_user_data was protected by RCU
@@ -127,11 +133,13 @@ static int gtp5g_encap_recv(struct sock *sk, struct sk_buff *skb)
     int ret = 0;
 
     gtp = rcu_dereference_sk_user_data(sk);
-    if (!gtp) {
+    if (!gtp)
+    {
         return 1;
     }
 
-    switch (udp_sk(sk)->encap_type) {
+    switch (udp_sk(sk)->encap_type)
+    {
     case UDP_ENCAP_GTP1U:
         ret = gtp1u_udp_encap_recv(gtp, skb);
         break;
@@ -139,7 +147,8 @@ static int gtp5g_encap_recv(struct sock *sk, struct sk_buff *skb)
         ret = -1; // Should not happen
     }
 
-    switch (ret) {
+    switch (ret)
+    {
     case PKT_TO_APP: // packet that gtp5g cannot handle
         GTP5G_TRC(gtp->dev, "Pass up to the process\n");
         break;
@@ -169,25 +178,28 @@ static int gtp1c_handle_echo_req(struct sk_buff *skb, struct gtp5g_dev *gtp)
     struct iphdr *iph;
     struct udphdr *udph;
 
-    __u8   flags = 0;
+    __u8 flags = 0;
     __be16 seq_number = 0;
 
     req_gtp1 = (struct gtpv1_hdr *)(skb->data + sizeof(struct udphdr));
 
     flags = req_gtp1->flags;
-    if (flags & GTPV1_HDR_FLG_SEQ) {
-         req_gtpOptHdr = (struct gtp1_hdr_opt *)(skb->data + sizeof(struct udphdr) 
-                                                            + sizeof(struct gtpv1_hdr));
-         seq_number = req_gtpOptHdr->seq_number;
-    } else {
+    if (flags & GTPV1_HDR_FLG_SEQ)
+    {
+        req_gtpOptHdr = (struct gtp1_hdr_opt *)(skb->data + sizeof(struct udphdr) + sizeof(struct gtpv1_hdr));
+        seq_number = req_gtpOptHdr->seq_number;
+    }
+    else
+    {
         GTP5G_ERR(gtp->dev, "GTP echo request shall bring sequence number\n");
         seq_number = 0;
     }
 
-    pskb_pull(skb, skb->len);          
+    pskb_pull(skb, skb->len);
 
     gtp_pkt = skb_push(skb, sizeof(struct gtpv1_echo_resp));
-    if (!gtp_pkt) {
+    if (!gtp_pkt)
+    {
         GTP5G_ERR(gtp->dev, "can not construct GTP Echo Response\n");
         return 1;
     }
@@ -209,26 +221,27 @@ static int gtp1c_handle_echo_req(struct sk_buff *skb, struct gtp5g_dev *gtp)
 
     iph = ip_hdr(skb);
     udph = udp_hdr(skb);
-  
-    rt = ip4_find_route(skb, iph, gtp->sk1u, gtp->dev, 
-        iph->daddr ,
-        iph->saddr, 
-        &fl4);
-    if (IS_ERR(rt)) {
-        GTP5G_ERR(gtp->dev, "no route for GTP echo response from %pI4\n", 
-        &iph->saddr);
+
+    rt = ip4_find_route(skb, iph, gtp->sk1u, gtp->dev,
+                        iph->daddr,
+                        iph->saddr,
+                        &fl4);
+    if (IS_ERR(rt))
+    {
+        GTP5G_ERR(gtp->dev, "no route for GTP echo response from %pI4\n",
+                  &iph->saddr);
         return 1;
     }
 
     udp_tunnel_xmit_skb(rt, gtp->sk1u, skb,
-                    fl4.saddr, fl4.daddr,
-                    iph->tos,
-                    ip4_dst_hoplimit(&rt->dst),
-                    0,
-                    udph->dest, udph->source,
-                    !net_eq(sock_net(gtp->sk1u),
-                        dev_net(gtp->dev)),
-                    false);
+                        fl4.saddr, fl4.daddr,
+                        iph->tos,
+                        ip4_dst_hoplimit(&rt->dst),
+                        0,
+                        udph->dest, udph->source,
+                        !net_eq(sock_net(gtp->sk1u),
+                                dev_net(gtp->dev)),
+                        false);
 
     return 0;
 }
@@ -242,30 +255,34 @@ static int gtp1u_udp_encap_recv(struct gtp5g_dev *gtp, struct sk_buff *skb)
     u8 gtp_type;
     u32 teid;
 
-    if (!pskb_may_pull(skb, pull_len)) {
+    if (!pskb_may_pull(skb, pull_len))
+    {
         GTP5G_ERR(gtp->dev, "Failed to pull skb length %#x\n", pull_len);
         return PKT_DROPPED;
     }
 
     gtpv1 = (struct gtpv1_hdr *)(skb->data + sizeof(struct udphdr));
-    if ((gtpv1->flags >> 5) != GTP_V1) {
+    if ((gtpv1->flags >> 5) != GTP_V1)
+    {
         GTP5G_ERR(gtp->dev, "GTP version is not v1: %#x\n",
-            gtpv1->flags);
+                  gtpv1->flags);
         return PKT_TO_APP;
     }
 
     gtp_type = gtpv1->type;
     teid = gtpv1->tid;
-    if (gtp_type == GTPV1_MSG_TYPE_ECHO_REQ) {
-        GTP5G_INF(gtp->dev, "GTP-C message type is GTP echo request: %#x\n",
-            gtp_type);
+    if (gtp_type == GTPV1_MSG_TYPE_ECHO_REQ)
+    {
+        GTP5G_TRC(gtp->dev, "GTP-C message type is GTP echo request: %#x\n",
+                  gtp_type);
 
         return gtp1c_handle_echo_req(skb, gtp);
     }
 
-    if (gtp_type != GTPV1_MSG_TYPE_TPDU && gtp_type != GTPV1_MSG_TYPE_EMARK) {
+    if (gtp_type != GTPV1_MSG_TYPE_TPDU && gtp_type != GTPV1_MSG_TYPE_EMARK)
+    {
         GTP5G_ERR(gtp->dev, "GTP-U message type is not a TPDU or End Marker: %#x\n",
-            gtp_type);
+                  gtp_type);
         return PKT_TO_APP;
     }
 
@@ -277,11 +294,13 @@ static int gtp1u_udp_encap_recv(struct gtp5g_dev *gtp, struct sk_buff *skb)
      *
      * TODO: Validate the Reserved flag set or not, if it is set then protocol error
      */
-    if (gtpv1->flags & GTPV1_HDR_FLG_MASK) {
+    if (gtpv1->flags & GTPV1_HDR_FLG_MASK)
+    {
         u8 *ext_hdr = NULL;
         hdrlen += sizeof(struct gtp1_hdr_opt);
         pull_len = hdrlen;
-        if (!pskb_may_pull(skb, pull_len)) {
+        if (!pskb_may_pull(skb, pull_len))
+        {
             GTP5G_ERR(gtp->dev, "Failed to pull skb length %#x\n", pull_len);
             return PKT_DROPPED;
         }
@@ -290,44 +309,50 @@ static int gtp1u_udp_encap_recv(struct gtp5g_dev *gtp, struct sk_buff *skb)
          * The length of the Extension header shall be defined in a variable length of 4 octets,
          * i.e. m+1 = n*4 octets, where n is a positive integer.
          */
-        while (*(ext_hdr = (u8 *)(skb->data + hdrlen - 1))) {
+        while (*(ext_hdr = (u8 *)(skb->data + hdrlen - 1)))
+        {
             u8 ext_hdr_type = *ext_hdr;
             unsigned int extlen;
             pull_len = hdrlen + 1; // 1 byte for the length of extension hdr
-            if (!pskb_may_pull(skb, pull_len)) {
+            if (!pskb_may_pull(skb, pull_len))
+            {
                 GTP5G_ERR(gtp->dev, "Failed to pull skb length %#x\n", pull_len);
                 return PKT_DROPPED;
             }
             extlen = (*((u8 *)(skb->data + hdrlen))) * 4; // total length of extension hdr
-            if (extlen == 0) {
+            if (extlen == 0)
+            {
                 GTP5G_ERR(gtp->dev, "Invalid extention header length\n");
                 return PKT_DROPPED;
             }
             hdrlen += extlen;
             pull_len = hdrlen;
-            if (!pskb_may_pull(skb, pull_len)) {
+            if (!pskb_may_pull(skb, pull_len))
+            {
                 GTP5G_ERR(gtp->dev, "Failed to pull skb length %#x\n", pull_len);
                 return PKT_DROPPED;
             }
-            switch (ext_hdr_type) {
-                case GTPV1_NEXT_EXT_HDR_TYPE_85:
-                {
-                    // ext_pdu_sess_ctr_t *etype85 = (ext_pdu_sess_ctr_t *) (skb->data + hdrlen);
-                    // pdu_sess_ctr_t *pdu_sess_info = &etype85->pdu_sess_ctr;
-
-                    // Commented the below code due to support N9 packet downlink
-                    // if (pdu_sess_info->type_spare == PDU_SESSION_INFO_TYPE0)
-                    //     return -1;
-
-                    //TODO: validate pdu_sess_ctr
-                    break;
-                }
+            switch (ext_hdr_type)
+            {
+            case GTPV1_NEXT_EXT_HDR_TYPE_85:
+            {
+                // ext_pdu_sess_ctr_t *etype85 = (ext_pdu_sess_ctr_t *) (skb->data + hdrlen);
+                // pdu_sess_ctr_t *pdu_sess_info = &etype85->pdu_sess_ctr;
+
+                // Commented the below code due to support N9 packet downlink
+                // if (pdu_sess_info->type_spare == PDU_SESSION_INFO_TYPE0)
+                //     return -1;
+
+                // TODO: validate pdu_sess_ctr
+                break;
+            }
             }
         }
     }
 
     pdr = pdr_find_by_gtp1u(gtp, skb, hdrlen, teid, gtp_type);
-    if (!pdr) {
+    if (!pdr)
+    {
         GTP5G_ERR(gtp->dev, "No PDR match this skb : teid[%x]\n", ntohl(teid));
         return PKT_DROPPED;
     }
@@ -335,40 +360,48 @@ static int gtp1u_udp_encap_recv(struct gtp5g_dev *gtp, struct sk_buff *skb)
     return gtp5g_rx(pdr, skb, hdrlen, gtp->role);
 }
 
-static int gtp5g_drop_skb_encap(struct sk_buff *skb, struct net_device *dev, 
-    struct pdr *pdr)
+static int gtp5g_drop_skb_encap(struct sk_buff *skb, struct net_device *dev,
+                                struct pdr *pdr)
 {
     struct gtpv1_hdr *gtp1 = (struct gtpv1_hdr *)(skb->data + sizeof(struct udphdr));
-    if (gtp1->type == GTPV1_MSG_TYPE_TPDU) {
+    if (gtp1->type == GTPV1_MSG_TYPE_TPDU)
+    {
         pdr->ul_drop_cnt++;
-        GTP5G_INF(NULL, "PDR (%u) UL_DROP_CNT (%llu)", pdr->id, pdr->ul_drop_cnt);
+        GTP5G_TRC(NULL, "PDR (%u) UL_DROP_CNT (%llu)", pdr->id, pdr->ul_drop_cnt);
     }
-    
+
     // release skb in outer function
     return PKT_DROPPED;
 }
 
-static int gtp5g_buf_skb_encap(struct sk_buff *skb, struct net_device *dev, 
-    unsigned int hdrlen, struct pdr *pdr, struct far *far)
+static int gtp5g_buf_skb_encap(struct sk_buff *skb, struct net_device *dev,
+                               unsigned int hdrlen, struct pdr *pdr, struct far *far)
 {
     struct gtpv1_hdr *gtp1 = (struct gtpv1_hdr *)(skb->data + sizeof(struct udphdr));
-    if (gtp1->type == GTPV1_MSG_TYPE_TPDU) {
+    if (gtp1->type == GTPV1_MSG_TYPE_TPDU)
+    {
         // Get rid of the GTP-U + UDP headers.
         if (iptunnel_pull_header(skb,
-                hdrlen,
-                skb->protocol,
-                !net_eq(sock_net(pdr->sk), dev_net(dev)))) {
+                                 hdrlen,
+                                 skb->protocol,
+                                 !net_eq(sock_net(pdr->sk), dev_net(dev))))
+        {
             GTP5G_ERR(dev, "Failed to pull GTP-U and UDP headers\n");
             return PKT_DROPPED;
         }
 
-        if (pdr_addr_is_netlink(pdr)) {
-            if (netlink_send(pdr, far, skb, dev_net(dev), NULL, 0) < 0) {
+        if (pdr_addr_is_netlink(pdr))
+        {
+            if (netlink_send(pdr, far, skb, dev_net(dev), NULL, 0) < 0)
+            {
                 GTP5G_ERR(dev, "Failed to send skb to netlink socket PDR(%u)", pdr->id);
                 ++pdr->ul_drop_cnt;
             }
-        } else {
-            if (unix_sock_send(pdr, far, skb->data, skb_headlen(skb), 0) < 0) {
+        }
+        else
+        {
+            if (unix_sock_send(pdr, far, skb->data, skb_headlen(skb), 0) < 0)
+            {
                 GTP5G_ERR(dev, "Failed to send skb to unix domain socket PDR(%u)", pdr->id);
                 ++pdr->ul_drop_cnt;
             }
@@ -390,9 +423,12 @@ static int netlink_send(struct pdr *pdr, struct far *far, struct sk_buff *skb_in
     int i, err;
     struct nlattr *nest_msg_type;
 
-    if (reports != NULL) {
+    if (reports != NULL)
+    {
         skb = genlmsg_new(NLMSG_GOODSIZE, GFP_ATOMIC);
-    } else {
+    }
+    else
+    {
         skb = genlmsg_new(
             nla_total_size_64bit(8) +
                 nla_total_size(2) +
@@ -412,37 +448,45 @@ static int netlink_send(struct pdr *pdr, struct far *far, struct sk_buff *skb_in
         return -ENOMEM;
     }
 
-    if (reports != NULL) {
+    if (reports != NULL)
+    {
         nest_msg_type = nla_nest_start(skb, GTP5G_REPORT);
 
-        for (i = 0; i < report_num; i++) {
+        for (i = 0; i < report_num; i++)
+        {
             gtp5g_genl_fill_ur(skb, &reports[i]);
         }
-        
+
         nla_nest_end(skb, nest_msg_type);
-    } else {
+    }
+    else
+    {
         nest_msg_type = nla_nest_start(skb, GTP5G_BUFFER);
 
         err = nla_put_u16(skb, GTP5G_BUFFER_ID, pdr->id);
-        if (err != 0) {
+        if (err != 0)
+        {
             nlmsg_free(skb);
             return err;
         }
 
         err = nla_put_u64_64bit(skb, GTP5G_BUFFER_SEID, pdr->seid, GTP5G_BUFFER_PAD);
-        if (err != 0) {
+        if (err != 0)
+        {
             nlmsg_free(skb);
             return err;
         }
 
         err = nla_put_u16(skb, GTP5G_BUFFER_ACTION, far->action);
-        if (err != 0) {
+        if (err != 0)
+        {
             nlmsg_free(skb);
             return err;
         }
 
         attr = nla_reserve(skb, GTP5G_BUFFER_PACKET, skb_in->len);
-        if (!attr) {
+        if (!attr)
+        {
             nlmsg_free(skb);
             return -EINVAL;
         }
@@ -466,28 +510,31 @@ static int unix_sock_send(struct pdr *pdr, struct far *far, void *buf, u32 len,
     int msg_kovlen;
     int total_kov_len = 0;
     int i, rt;
-    u8  type_hdr[1] = {TYPE_BUFFER};
+    u8 type_hdr[1] = {TYPE_BUFFER};
     u64 self_seid_hdr[1] = {pdr->seid};
     u16 self_hdr[2] = {pdr->id, far->action};
     u32 self_num_hdr[1] = {report_num};
 
-    if (pdr_addr_is_netlink(pdr)) {
+    if (pdr_addr_is_netlink(pdr))
+    {
         return -EINVAL;
     }
 
-    if (!sock) {
+    if (!sock)
+    {
         GTP5G_ERR(NULL, "Failed Socket is NULL\n");
         return -EINVAL;
     }
 
     memset(&msg, 0, sizeof(msg));
-    if (report_num > 0) {
+    if (report_num > 0)
+    {
         type_hdr[0] = TYPE_URR_REPORT;
     }
 
     msg_kovlen = MSG_KOV_LEN;
     kov = kmalloc_array(msg_kovlen, sizeof(struct kvec),
-        GFP_KERNEL);
+                        GFP_KERNEL);
     if (kov == NULL)
         return -ENOMEM;
 
@@ -498,12 +545,14 @@ static int unix_sock_send(struct pdr *pdr, struct far *far, void *buf, u32 len,
     kov[1].iov_base = self_seid_hdr;
     kov[1].iov_len = sizeof(self_seid_hdr);
 
-    //buf is report in this case
-    if (report_num > 0) {
+    // buf is report in this case
+    if (report_num > 0)
+    {
         kov[2].iov_base = self_num_hdr;
         kov[2].iov_len = sizeof(self_num_hdr);
     }
-    else {
+    else
+    {
         kov[2].iov_base = self_hdr;
         kov[2].iov_len = sizeof(self_hdr);
     }
@@ -527,48 +576,65 @@ static int unix_sock_send(struct pdr *pdr, struct far *far, void *buf, u32 len,
     return rt;
 }
 
-bool increment_and_check_counter(struct VolumeMeasurement *volmeasure, struct Volume *volume, u64 vol, bool uplink, bool mnop){
-    if (!volmeasure) {
+bool increment_and_check_counter(struct VolumeMeasurement *volmeasure, struct Volume *volume, u64 vol, bool uplink, bool mnop)
+{
+    if (!volmeasure)
+    {
         return false;
     }
 
-    if (vol == 0) {
+    if (vol == 0)
+    {
         return false;
     }
 
-    if (mnop) {
-        if (uplink) {
+    if (mnop)
+    {
+        if (uplink)
+        {
             volmeasure->uplinkPktNum++;
-        } else {
+        }
+        else
+        {
             volmeasure->downlinkPktNum++;
         }
         volmeasure->totalPktNum = volmeasure->uplinkPktNum + volmeasure->downlinkPktNum;
     }
 
-    if (uplink) {
+    if (uplink)
+    {
         volmeasure->uplinkVolume += vol;
-    } else {
+    }
+    else
+    {
         volmeasure->downlinkVolume += vol;
     }
 
     volmeasure->totalVolume = volmeasure->uplinkVolume + volmeasure->downlinkVolume;
 
-    if (!volume) {
+    if (!volume)
+    {
         return false;
     }
 
-    if (volume->totalVolume && (volmeasure->totalVolume >= volume->totalVolume) && (volume->flag & URR_VOLUME_TOVOL)) {
+    if (volume->totalVolume && (volmeasure->totalVolume >= volume->totalVolume) && (volume->flag & URR_VOLUME_TOVOL))
+    {
         return true;
-    } else if (volume->uplinkVolume && (volmeasure->uplinkVolume >= volume->uplinkVolume) && (volume->flag & URR_VOLUME_ULVOL)) {
+    }
+    else if (volume->uplinkVolume && (volmeasure->uplinkVolume >= volume->uplinkVolume) && (volume->flag & URR_VOLUME_ULVOL))
+    {
         return true;
-    } else if (volume->downlinkVolume && (volmeasure->downlinkVolume >= volume->downlinkVolume) && (volume->flag & URR_VOLUME_DLVOL)) {
+    }
+    else if (volume->downlinkVolume && (volmeasure->downlinkVolume >= volume->downlinkVolume) && (volume->flag & URR_VOLUME_DLVOL))
+    {
         return true;
     }
 
     return false;
 }
 
-int update_urr_counter_and_send_report(struct pdr *pdr, struct far *far, u64 vol, u64 vol_mbqe, bool uplink) {
+int update_urr_counter_and_send_report(struct pdr *pdr, struct far *far, u64 vol, u64 vol_mbqe, bool uplink)
+{
     struct gtp5g_dev *gtp = netdev_priv(pdr->dev);
     int i;
     int ret = 1;
@@ -580,37 +646,44 @@ int update_urr_counter_and_send_report(struct pdr *pdr, struct far *far, u64 vol
     struct usage_report *report = NULL;
     bool mnop;
     struct sk_buff *skb;
-    
-    // vol_mbqe(volume of measurement before QoS enforcement) is zero(payload is zero), 
+
+    // vol_mbqe(volume of measurement before QoS enforcement) is zero(payload is zero),
     // no need to add volume and packet count
-    if (vol_mbqe == 0) {
+    if (vol_mbqe == 0)
+    {
         return ret;
     }
 
-    urrs = kzalloc(sizeof(struct urr *) * pdr->urr_num , GFP_ATOMIC);
-    triggers = kzalloc(sizeof(u32) * pdr->urr_num , GFP_ATOMIC);
-    if (!urrs || !triggers) {
+    urrs = kzalloc(sizeof(struct urr *) * pdr->urr_num, GFP_ATOMIC);
+    triggers = kzalloc(sizeof(u32) * pdr->urr_num, GFP_ATOMIC);
+    if (!urrs || !triggers)
+    {
         ret = -1;
         goto err1;
     }
 
-    for (i = 0; i < pdr->urr_num; i++) {
-        urr = find_urr_by_id(gtp, pdr->seid,  pdr->urr_ids[i]);
+    for (i = 0; i < pdr->urr_num; i++)
+    {
+        urr = find_urr_by_id(gtp, pdr->seid, pdr->urr_ids[i]);
 
         mnop = false;
         if (urr->info & URR_INFO_MNOP)
             mnop = true;
 
-        if (!(urr->info & URR_INFO_INAM)) {
-            if (urr->method & URR_METHOD_VOLUM) {
-                if (urr->trigger == 0) {
+        if (!(urr->info & URR_INFO_INAM))
+        {
+            if (urr->method & URR_METHOD_VOLUM)
+            {
+                if (urr->trigger == 0)
+                {
                     GTP5G_ERR(pdr->dev, "no supported trigger(%u) in URR(%u) and related to PDR(%u)",
-                        urr->trigger, urr->id, pdr->id);
+                              urr->trigger, urr->id, pdr->id);
                     ret = 0;
                     goto err1;
                 }
 
-                if (urr->trigger & URR_RPT_TRIGGER_START && uplink) {
+                if (urr->trigger & URR_RPT_TRIGGER_START && uplink)
+                {
                     triggers[report_num] = USAR_TRIGGER_START;
                     urrs[report_num++] = urr;
                     urr_quota_exhaust_action(urr, gtp);
@@ -618,61 +691,81 @@ int update_urr_counter_and_send_report(struct pdr *pdr, struct far *far, u64 vol
                     continue;
                 }
 
-                if (urr->info & URR_INFO_MBQE) {
+                if (urr->info & URR_INFO_MBQE)
+                {
                     volume = vol_mbqe;
-                } else {
+                }
+                else
+                {
                     volume = vol;
                 }
                 // Caculate Volume measurement for each trigger
-                if (urr->trigger & URR_RPT_TRIGGER_VOLTH) {
-                    if (increment_and_check_counter(&urr->bytes, &urr->volumethreshold, volume, uplink, mnop)) {
+                if (urr->trigger & URR_RPT_TRIGGER_VOLTH)
+                {
+                    if (increment_and_check_counter(&urr->bytes, &urr->volumethreshold, volume, uplink, mnop))
+                    {
                         triggers[report_num] = USAR_TRIGGER_VOLTH;
                         urrs[report_num++] = urr;
                     }
-                } else {
+                }
+                else
+                {
                     // For other triggers, only increment bytes
                     increment_and_check_counter(&urr->bytes, NULL, volume, uplink, mnop);
                 }
-                if (urr->trigger & URR_RPT_TRIGGER_VOLQU) {
-                    if (increment_and_check_counter(&urr->consumed, &urr->volumequota, volume, uplink, mnop)) {
+                if (urr->trigger & URR_RPT_TRIGGER_VOLQU)
+                {
+                    if (increment_and_check_counter(&urr->consumed, &urr->volumequota, volume, uplink, mnop))
+                    {
                         triggers[report_num] = USAR_TRIGGER_VOLQU;
                         urrs[report_num++] = urr;
                         urr_quota_exhaust_action(urr, gtp);
-                        GTP5G_INF(NULL, "URR (%u) Quota Exhaust, stop measure", urr->id);
+                        GTP5G_TRC(NULL, "URR (%u) Quota Exhaust, stop measure", urr->id);
                     }
                 }
             }
-        } else {
+        }
+        else
+        {
             GTP5G_TRC(pdr->dev, "URR stop measurement");
         }
     }
-    if (report_num > 0) {
+    if (report_num > 0)
+    {
         len = sizeof(*report) * report_num;
 
         report = kzalloc(len, GFP_ATOMIC);
-        if (!report) {
+        if (!report)
+        {
             ret = -1;
             goto err1;
         }
 
-        for (i = 0; i < report_num; i++) {
+        for (i = 0; i < report_num; i++)
+        {
             // TODO: FAR ID for Quota Action IE for indicating the action while no quota is granted
-            if (triggers[i] == USAR_TRIGGER_START){
+            if (triggers[i] == USAR_TRIGGER_START)
+            {
                 ret = DONT_SEND_UL_PACKET;
-            }                 
+            }
             convert_urr_to_report(urrs[i], &report[i]);
 
             report[i].trigger = triggers[i];
         }
 
-        if (pdr_addr_is_netlink(pdr)) {
-            if (netlink_send(pdr, far, skb, dev_net(pdr->dev), report, report_num) < 0) {
+        if (pdr_addr_is_netlink(pdr))
+        {
+            if (netlink_send(pdr, far, skb, dev_net(pdr->dev), report, report_num) < 0)
+            {
                 GTP5G_ERR(pdr->dev, "Failed to send report to netlink socket PDR(%u)", pdr->id);
                 ret = -1;
                 goto err1;
             }
-        } else {
-            if (unix_sock_send(pdr, far, report, len, report_num) < 0) {
+        }
+        else
+        {
+            if (unix_sock_send(pdr, far, report, len, report_num) < 0)
+            {
                 GTP5G_ERR(pdr->dev, "Failed to send report to unix domain socket PDR(%u)", pdr->id);
                 ret = -1;
                 goto err1;
@@ -681,43 +774,51 @@ int update_urr_counter_and_send_report(struct pdr *pdr, struct far *far, u64 vol
     }
 
 err1:
-    if (report) {
+    if (report)
+    {
         kfree(report);
     }
-    if (urrs) {
+    if (urrs)
+    {
         kfree(urrs);
     }
-    if (triggers) {
+    if (triggers)
+    {
         kfree(triggers);
     }
     return ret;
 }
 
 static int gtp5g_rx(struct pdr *pdr, struct sk_buff *skb,
-    unsigned int hdrlen, unsigned int role)
+                    unsigned int hdrlen, unsigned int role)
 {
     int rt = -1;
     struct far *far = rcu_dereference(pdr->far);
     struct qer __rcu *qer_with_rate = rcu_dereference(pdr->qer_with_rate);
 
-    if (!far) {
+    if (!far)
+    {
         GTP5G_ERR(pdr->dev, "FAR not exists for PDR(%u)\n", pdr->id);
         goto out;
     }
 
     // TODO: not reading the value of outer_header_removal now,
     // just check if it is assigned.
-    if (pdr->outer_header_removal) {
+    if (pdr->outer_header_removal)
+    {
         // One and only one of the DROP, FORW and BUFF flags shall be set to 1.
         // The NOCP flag may only be set if the BUFF flag is set.
         // The DUPL flag may be set with any of the DROP, FORW, BUFF and NOCP flags.
-        switch(far->action & FAR_ACTION_MASK) {
+        switch (far->action & FAR_ACTION_MASK)
+        {
         case FAR_ACTION_DROP:
             rt = gtp5g_drop_skb_encap(skb, pdr->dev, pdr);
             break;
         case FAR_ACTION_FORW:
-            if (qer_with_rate != NULL) {
-                if (qer_with_rate->ul_dl_gate & QER_UL_GATE_CLOSE) {
+            if (qer_with_rate != NULL)
+            {
+                if (qer_with_rate->ul_dl_gate & QER_UL_GATE_CLOSE)
+                {
                     GTP5G_TRC(pdr->dev, "QER UL gate is closed, drop the packet");
                     return PKT_DROPPED;
                 }
@@ -729,21 +830,22 @@ static int gtp5g_rx(struct pdr *pdr, struct sk_buff *skb,
             break;
         default:
             GTP5G_ERR(pdr->dev, "Unhandled apply action(%u) in FAR(%u) and related to PDR(%u)\n",
-                far->action, far->id, pdr->id);
+                      far->action, far->id, pdr->id);
         }
         goto out;
-    } 
+    }
 
     // TODO: this action is not supported
     GTP5G_ERR(pdr->dev, "Uplink: PDR(%u) didn't has a OHR information "
-        "(which routed to the gtp interface and matches a PDR)\n", pdr->id);
+                        "(which routed to the gtp interface and matches a PDR)\n",
+              pdr->id);
 
 out:
     return rt;
 }
 
 static int gtp5g_fwd_skb_encap(struct sk_buff *skb, struct net_device *dev,
-    unsigned int hdrlen, struct pdr *pdr, struct far *far)
+                               unsigned int hdrlen, struct pdr *pdr, struct far *far)
 {
     struct forwarding_parameter *fwd_param = rcu_dereference(far->fwd_param);
     struct outer_header_creation *hdr_creation;
@@ -755,39 +857,46 @@ static int gtp5g_fwd_skb_encap(struct sk_buff *skb, struct net_device *dev,
     int ret;
     u64 volume, volume_mbqe = 0;
 
-    TrafficPolicer* tp = NULL;
+    TrafficPolicer *tp = NULL;
     Color color = Green;
     struct qer __rcu *qer_with_rate = NULL;
-    
+
     if (gtp1->type == GTPV1_MSG_TYPE_TPDU)
         volume_mbqe = ip4_rm_header(skb, hdrlen);
 
     qer_with_rate = rcu_dereference(pdr->qer_with_rate);
     if (qer_with_rate != NULL)
         tp = qer_with_rate->ul_policer;
-    if (get_qos_enable() && tp != NULL) {
+    if (get_qos_enable() && tp != NULL)
+    {
         color = policePacket(tp, volume_mbqe);
     }
-    if (color == Red) {
+    if (color == Red)
+    {
         volume = 0;
-    } else {
+    }
+    else
+    {
         volume = volume_mbqe;
     }
 
-    if (fwd_param) {
+    if (fwd_param)
+    {
         if ((fwd_policy = fwd_param->fwd_policy))
             skb->mark = fwd_policy->mark;
 
-        if ((hdr_creation = fwd_param->hdr_creation)) {
+        if ((hdr_creation = fwd_param->hdr_creation))
+        {
             // Just modify the teid and packet dest ip
             gtp1->tid = hdr_creation->teid;
 
             skb_push(skb, 20); // L3 Header Length
             iph = ip_hdr(skb);
 
-            if (!pdr->pdi->f_teid) {
+            if (!pdr->pdi->f_teid)
+            {
                 GTP5G_ERR(dev, "Failed to hdr removal + creation "
-                    "due to pdr->pdi->f_teid not exist\n");
+                               "due to pdr->pdi->f_teid not exist\n");
                 return -1;
             }
 
@@ -798,23 +907,30 @@ static int gtp5g_fwd_skb_encap(struct sk_buff *skb, struct net_device *dev,
             uh = udp_hdr(skb);
             uh->check = 0;
 
-            if (pdr->urr_num != 0) {
+            if (pdr->urr_num != 0)
+            {
                 ret = update_urr_counter_and_send_report(pdr, far, volume, volume_mbqe, true);
-                if (ret < 0) {
-                    if (ret == DONT_SEND_UL_PACKET) {
-                        GTP5G_INF(pdr->dev, "Should not foward the first uplink packet");
+                if (ret < 0)
+                {
+                    if (ret == DONT_SEND_UL_PACKET)
+                    {
+                        GTP5G_TRC(pdr->dev, "Should not foward the first uplink packet");
                         return PKT_DROPPED;
-                    } else {
+                    }
+                    else
+                    {
                         GTP5G_ERR(pdr->dev, "Fail to send Usage Report");
                     }
                 }
             }
 
-            if (color == Red) {
+            if (color == Red)
+            {
                 GTP5G_TRC(pdr->dev, "Drop red packet");
                 return PKT_DROPPED;
             }
-            if (ip_xmit(skb, pdr->sk, dev) < 0) {
+            if (ip_xmit(skb, pdr->sk, dev) < 0)
+            {
                 GTP5G_ERR(dev, "Failed to transmit skb through ip_xmit\n");
                 return PKT_DROPPED;
             }
@@ -823,17 +939,19 @@ static int gtp5g_fwd_skb_encap(struct sk_buff *skb, struct net_device *dev,
         }
     }
 
-    if (gtp1->type != GTPV1_MSG_TYPE_TPDU) {
+    if (gtp1->type != GTPV1_MSG_TYPE_TPDU)
+    {
         GTP5G_WAR(dev, "Uplink: GTPv1 msg type is not TPDU\n");
         return -1;
     }
 
     // Get rid of the GTP-U + UDP headers.
     if (iptunnel_pull_header(skb,
-            hdrlen, 
-            skb->protocol,
-            !net_eq(sock_net(pdr->sk), 
-            dev_net(dev)))) {
+                             hdrlen,
+                             skb->protocol,
+                             !net_eq(sock_net(pdr->sk),
+                                     dev_net(dev))))
+    {
         GTP5G_ERR(dev, "Failed to pull GTP-U and UDP headers\n");
         return PKT_DROPPED;
     }
@@ -859,37 +977,40 @@ static int gtp5g_fwd_skb_encap(struct sk_buff *skb, struct net_device *dev,
 
     pdr->ul_pkt_cnt++;
     pdr->ul_byte_cnt += skb->len; /* length without GTP header */
-    GTP5G_INF(NULL, "PDR (%u) UL_PKT_CNT (%llu) UL_BYTE_CNT (%llu)", pdr->id, pdr->ul_pkt_cnt, pdr->ul_byte_cnt);    
- 
-    if (pdr->urr_num != 0) {
+    GTP5G_TRC(NULL, "PDR (%u) UL_PKT_CNT (%llu) UL_BYTE_CNT (%llu)", pdr->id, pdr->ul_pkt_cnt, pdr->ul_byte_cnt);
+
+    if (pdr->urr_num != 0)
+    {
         if (update_urr_counter_and_send_report(pdr, far, volume, volume_mbqe, true) < 0)
             GTP5G_ERR(pdr->dev, "Fail to send Usage Report");
     }
-    
-    if (color == Red) {
+
+    if (color == Red)
+    {
         GTP5G_TRC(pdr->dev, "Drop red packet");
         return PKT_DROPPED;
     }
     ret = netif_rx(skb);
-    if (ret != NET_RX_SUCCESS) {
+    if (ret != NET_RX_SUCCESS)
+    {
         GTP5G_ERR(dev, "Uplink: Packet got dropped\n");
     }
 
     return PKT_FORWARDED;
 }
 
-static int gtp5g_drop_skb_ipv4(struct sk_buff *skb, struct net_device *dev, 
-    struct pdr *pdr)
+static int gtp5g_drop_skb_ipv4(struct sk_buff *skb, struct net_device *dev,
+                               struct pdr *pdr)
 {
     ++pdr->dl_drop_cnt;
-    GTP5G_INF(NULL, "PDR (%u) DL_DROP_CNT (%llu)", pdr->id, pdr->dl_drop_cnt);
+    GTP5G_TRC(NULL, "PDR (%u) DL_DROP_CNT (%llu)", pdr->id, pdr->dl_drop_cnt);
     dev_kfree_skb(skb);
     return FAR_ACTION_DROP;
 }
 
-static int gtp5g_fwd_skb_ipv4(struct sk_buff *skb, 
-    struct net_device *dev, struct gtp5g_pktinfo *pktinfo, 
-    struct pdr *pdr, struct far *far)
+static int gtp5g_fwd_skb_ipv4(struct sk_buff *skb,
+                              struct net_device *dev, struct gtp5g_pktinfo *pktinfo,
+                              struct pdr *pdr, struct far *far)
 {
     struct rtable *rt;
     struct flowi4 fl4;
@@ -898,69 +1019,77 @@ static int gtp5g_fwd_skb_ipv4(struct sk_buff *skb,
     u64 volume, volume_mbqe = 0;
     struct forwarding_parameter *fwd_param;
 
-    TrafficPolicer* tp = NULL;
+    TrafficPolicer *tp = NULL;
     Color color = Green;
     struct qer __rcu *qer_with_rate = NULL;
-    
-    if (!far) {
+
+    if (!far)
+    {
         GTP5G_ERR(dev, "Unknown RAN address\n");
         goto err;
     }
 
     fwd_param = rcu_dereference(far->fwd_param);
     if (!(fwd_param &&
-        fwd_param->hdr_creation)) {
+          fwd_param->hdr_creation))
+    {
         GTP5G_ERR(dev, "Unknown RAN address\n");
         goto err;
     }
 
     hdr_creation = fwd_param->hdr_creation;
-    rt = ip4_find_route(skb, 
-        iph, 
-        pdr->sk,
-        dev, 
-        pdr->role_addr_ipv4.s_addr, 
-        hdr_creation->peer_addr_ipv4.s_addr, 
-        &fl4);
+    rt = ip4_find_route(skb,
+                        iph,
+                        pdr->sk,
+                        dev,
+                        pdr->role_addr_ipv4.s_addr,
+                        hdr_creation->peer_addr_ipv4.s_addr,
+                        &fl4);
     if (IS_ERR(rt))
         goto err;
 
     gtp5g_set_pktinfo_ipv4(pktinfo,
-            pdr->sk, 
-            iph, 
-            hdr_creation,
-            pdr->qfi, 
-            far->seq_number,
-            rt, 
-            &fl4, 
-            dev);
+                           pdr->sk,
+                           iph,
+                           hdr_creation,
+                           pdr->qfi,
+                           far->seq_number,
+                           rt,
+                           &fl4,
+                           dev);
 
     far->seq_number++;
     pdr->dl_pkt_cnt++;
     pdr->dl_byte_cnt += skb->len;
-    GTP5G_INF(NULL, "PDR (%u) DL_PKT_CNT (%llu) DL_BYTE_CNT (%llu)", pdr->id, pdr->dl_pkt_cnt, pdr->dl_byte_cnt);
+    GTP5G_TRC(NULL, "PDR (%u) DL_PKT_CNT (%llu) DL_BYTE_CNT (%llu)", pdr->id, pdr->dl_pkt_cnt, pdr->dl_byte_cnt);
 
     volume_mbqe = ip4_rm_header(skb, 0);
 
     qer_with_rate = rcu_dereference(pdr->qer_with_rate);
     if (qer_with_rate != NULL)
         tp = qer_with_rate->dl_policer;
-    if (get_qos_enable() && tp != NULL) {
+    if (get_qos_enable() && tp != NULL)
+    {
         color = policePacket(tp, volume_mbqe);
     }
-    if (color == Red) {
+    if (color == Red)
+    {
         volume = 0;
-    } else {
+    }
+    else
+    {
         volume = volume_mbqe;
     }
 
     gtp5g_push_header(skb, pktinfo);
 
-    if (pdr->urr_num != 0) {
+    if (pdr->urr_num != 0)
+    {
         if (update_urr_counter_and_send_report(pdr, far, volume, volume_mbqe, false) < 0)
             GTP5G_ERR(pdr->dev, "Fail to send Usage Report");
     }
-    if (color == Red) {
+    if (color == Red)
+    {
         GTP5G_TRC(pdr->dev, "Drop red packet");
         return PKT_DROPPED;
     }
@@ -970,16 +1099,21 @@ err:
 }
 
 static int gtp5g_buf_skb_ipv4(struct sk_buff *skb, struct net_device *dev,
-    struct pdr *pdr, struct far *far)
+                              struct pdr *pdr, struct far *far)
 {
-    if (pdr_addr_is_netlink(pdr)) {
-        if (netlink_send(pdr, far, skb, dev_net(dev), NULL, 0) < 0) {
+    if (pdr_addr_is_netlink(pdr))
+    {
+        if (netlink_send(pdr, far, skb, dev_net(dev), NULL, 0) < 0)
+        {
             GTP5G_ERR(dev, "Failed to send skb to netlink socket PDR(%u)", pdr->id);
             ++pdr->dl_drop_cnt;
         }
-    } else {
+    }
+    else
+    {
         // TODO: handle nonlinear part
-        if (unix_sock_send(pdr, far, skb->data, skb_headlen(skb), 0) < 0) {
+        if (unix_sock_send(pdr, far, skb->data, skb_headlen(skb), 0) < 0)
+        {
             GTP5G_ERR(dev, "Failed to send skb to unix domain socket PDR(%u)", pdr->id);
             ++pdr->dl_drop_cnt;
         }
@@ -990,12 +1124,12 @@ static int gtp5g_buf_skb_ipv4(struct sk_buff *skb, struct net_device *dev,
 }
 
 int gtp5g_handle_skb_ipv4(struct sk_buff *skb, struct net_device *dev,
-    struct gtp5g_pktinfo *pktinfo)
+                          struct gtp5g_pktinfo *pktinfo)
 {
     struct gtp5g_dev *gtp = netdev_priv(dev);
     struct pdr *pdr;
     struct far *far;
-    //struct gtp5g_qer *qer;
+    // struct gtp5g_qer *qer;
     struct iphdr *iph;
     struct qer __rcu *qer_with_rate = NULL;
 
@@ -1008,31 +1142,36 @@ int gtp5g_handle_skb_ipv4(struct sk_buff *skb, struct net_device *dev,
     else
         pdr = pdr_find_by_ipv4(gtp, skb, 0, iph->saddr);
 
-    if (!pdr) {
-        GTP5G_INF(dev, "no PDR found for %pI4, skip\n", &iph->daddr);
+    if (!pdr)
+    {
+        GTP5G_TRC(dev, "no PDR found for %pI4, skip\n", &iph->daddr);
         return -ENOENT;
     }
 
-    /* TODO: QoS rule have to apply before apply FAR 
+    /* TODO: QoS rule have to apply before apply FAR
      * */
-    //qer = rcu_dereference(pdr->qer);
-    //if (qer) {
-    //    GTP5G_ERR(dev, "%s:%d QER Rule found, id(%#x) qfi(%#x) TODO\n", 
-    //            __func__, __LINE__, qer->id, qer->qfi);
-    //}
+    // qer = rcu_dereference(pdr->qer);
+    // if (qer) {
+    //     GTP5G_ERR(dev, "%s:%d QER Rule found, id(%#x) qfi(%#x) TODO\n",
+    //             __func__, __LINE__, qer->id, qer->qfi);
+    // }
 
     qer_with_rate = rcu_dereference(pdr->qer_with_rate);
     far = rcu_dereference(pdr->far);
-    if (far) {
+    if (far)
+    {
         // One and only one of the DROP, FORW and BUFF flags shall be set to 1.
         // The NOCP flag may only be set if the BUFF flag is set.
         // The DUPL flag may be set with any of the DROP, FORW, BUFF and NOCP flags.
-        switch (far->action & FAR_ACTION_MASK) {
+        switch (far->action & FAR_ACTION_MASK)
+        {
         case FAR_ACTION_DROP:
             return gtp5g_drop_skb_ipv4(skb, dev, pdr);
         case FAR_ACTION_FORW:
-            if (qer_with_rate != NULL) {
-                if (qer_with_rate->ul_dl_gate & QER_DL_GATE_CLOSE) {
+            if (qer_with_rate != NULL)
+            {
+                if (qer_with_rate->ul_dl_gate & QER_DL_GATE_CLOSE)
+                {
                     GTP5G_TRC(pdr->dev, "QER DL gate is closed, drop the packet");
                     return PKT_DROPPED;
                 }
@@ -1042,7 +1181,7 @@ int gtp5g_handle_skb_ipv4(struct sk_buff *skb, struct net_device *dev,
             return gtp5g_buf_skb_ipv4(skb, dev, pdr, far);
         default:
             GTP5G_ERR(dev, "Unspec apply action(%u) in FAR(%u) and related to PDR(%u)",
-                far->action, far->id, pdr->id);
+                      far->action, far->id, pdr->id);
         }
     }
 
diff --git a/src/gtpu/link.c b/src/gtpu/link.c
index c45ab02..9f85e84 100644
--- a/src/gtpu/link.c
+++ b/src/gtpu/link.c
@@ -12,9 +12,9 @@
 #include "proc.h"
 
 const struct nla_policy gtp5g_policy[IFLA_GTP5G_MAX + 1] = {
-    [IFLA_GTP5G_FD1]             = { .type = NLA_U32 },
-    [IFLA_GTP5G_PDR_HASHSIZE]    = { .type = NLA_U32 },
-    [IFLA_GTP5G_ROLE]            = { .type = NLA_U32 },
+    [IFLA_GTP5G_FD1] = {.type = NLA_U32},
+    [IFLA_GTP5G_PDR_HASHSIZE] = {.type = NLA_U32},
+    [IFLA_GTP5G_ROLE] = {.type = NLA_U32},
 };
 
 static void gtp5g_link_setup(struct net_device *dev)
@@ -25,9 +25,9 @@ static void gtp5g_link_setup(struct net_device *dev)
     dev->hard_header_len = 0;
     dev->addr_len = 0;
     dev->mtu = ETH_DATA_LEN -
-        (sizeof(struct iphdr) +
-         sizeof(struct udphdr) +
-         sizeof(struct gtpv1_hdr));
+               (sizeof(struct iphdr) +
+                sizeof(struct udphdr) +
+                sizeof(struct gtpv1_hdr));
 
     /* Zero header length. */
     dev->type = ARPHRD_NONE;
@@ -41,13 +41,13 @@ static void gtp5g_link_setup(struct net_device *dev)
      * what are the extension header going to support
      * */
     dev->needed_headroom = LL_MAX_HEADER +
-        sizeof(struct iphdr) +
-        sizeof(struct udphdr) +
-        sizeof(struct gtpv1_hdr);
+                           sizeof(struct iphdr) +
+                           sizeof(struct udphdr) +
+                           sizeof(struct gtpv1_hdr);
 }
 
 static int gtp5g_validate(struct nlattr *tb[], struct nlattr *data[],
-    struct netlink_ext_ack *extack)
+                          struct netlink_ext_ack *extack)
 {
     if (!data)
         return -EINVAL;
@@ -56,8 +56,8 @@ static int gtp5g_validate(struct nlattr *tb[], struct nlattr *data[],
 }
 
 static int gtp5g_newlink(struct net *src_net, struct net_device *dev,
-    struct nlattr *tb[], struct nlattr *data[],
-    struct netlink_ext_ack *extack)
+                         struct nlattr *tb[], struct nlattr *data[],
+                         struct netlink_ext_ack *extack)
 {
     struct gtp5g_dev *gtp;
     struct gtp5g_net *gn;
@@ -68,40 +68,45 @@ static int gtp5g_newlink(struct net *src_net, struct net_device *dev,
 
     gtp = netdev_priv(dev);
 
-    if (!data[IFLA_GTP5G_FD1]) {
+    if (!data[IFLA_GTP5G_FD1])
+    {
         GTP5G_ERR(NULL, "Failed to create a new link\n");
         return -EINVAL;
     }
     fd1 = nla_get_u32(data[IFLA_GTP5G_FD1]);
-    sk = gtp5g_encap_enable(fd1, UDP_ENCAP_GTP1U, gtp);
+    sk = up3_create(fd1, UDP_ENCAP_GTP1U, gtp);
     if (IS_ERR(sk))
         return PTR_ERR(sk);
     gtp->sk1u = sk;
-    
-    if (data[IFLA_GTP5G_ROLE]) {
+
+    if (data[IFLA_GTP5G_ROLE])
+    {
         role = nla_get_u32(data[IFLA_GTP5G_ROLE]);
-        if (role > GTP5G_ROLE_RAN) {
+        if (role > GTP5G_ROLE_RAN)
+        {
             if (sk)
                 gtp5g_encap_disable(sk);
             return -EINVAL;
         }
     }
     gtp->role = role;
-    
+
     if (!data[IFLA_GTP5G_PDR_HASHSIZE])
         hashsize = 1024;
     else
         hashsize = nla_get_u32(data[IFLA_GTP5G_PDR_HASHSIZE]);
 
     err = dev_hashtable_new(gtp, hashsize);
-    if (err < 0) {
+    if (err < 0)
+    {
         gtp5g_encap_disable(gtp->sk1u);
         GTP5G_ERR(dev, "Failed to create a hash table\n");
         goto out_encap;
     }
 
     err = register_netdevice(dev);
-    if (err < 0) {
+    if (err < 0)
+    {
         netdev_dbg(dev, "failed to register new netdev %d\n", err);
         gtp5g_hashtable_free(gtp);
         gtp5g_encap_disable(gtp->sk1u);
@@ -112,7 +117,7 @@ static int gtp5g_newlink(struct net *src_net, struct net_device *dev,
     list_add_rcu(&gtp->list, &gn->gtp5g_dev_list);
     list_add_rcu(&gtp->proc_list, get_proc_gtp5g_dev_list_head());
 
-    GTP5G_LOG(dev, "Registered a new 5G GTP interface\n");
+    GTP5G_TRC(dev, "Registered a new 5G GTP interface\n");
     return 0;
 out_hashtable:
     gtp5g_hashtable_free(gtp);
@@ -130,7 +135,7 @@ static void gtp5g_dellink(struct net_device *dev, struct list_head *head)
     list_del_rcu(&gtp->proc_list);
     unregister_netdevice_queue(dev, head);
 
-    GTP5G_LOG(dev, "De-registered 5G GTP interface\n");
+    GTP5G_TRC(dev, "De-registered 5G GTP interface\n");
 }
 
 static size_t gtp5g_get_size(const struct net_device *dev)
@@ -152,16 +157,16 @@ nla_put_failure:
 }
 
 struct rtnl_link_ops gtp5g_link_ops __read_mostly = {
-    .kind         = "gtp5g",
-    .maxtype      = IFLA_GTP5G_MAX,
-    .policy       = gtp5g_policy,
-    .priv_size    = sizeof(struct gtp5g_dev),
-    .setup        = gtp5g_link_setup,
-    .validate     = gtp5g_validate,
-    .newlink      = gtp5g_newlink,
-    .dellink      = gtp5g_dellink,
-    .get_size     = gtp5g_get_size,
-    .fill_info    = gtp5g_fill_info,
+    .kind = "gtp5g",
+    .maxtype = IFLA_GTP5G_MAX,
+    .policy = gtp5g_policy,
+    .priv_size = sizeof(struct gtp5g_dev),
+    .setup = gtp5g_link_setup,
+    .validate = gtp5g_validate,
+    .newlink = gtp5g_newlink,
+    .dellink = gtp5g_dellink,
+    .get_size = gtp5g_get_size,
+    .fill_info = gtp5g_fill_info,
 };
 
 void gtp5g_link_all_del(struct list_head *dev_list)
diff --git a/src/gtpu/pktinfo.c b/src/gtpu/pktinfo.c
index 48503d1..0502231 100644
--- a/src/gtpu/pktinfo.c
+++ b/src/gtpu/pktinfo.c
@@ -13,44 +13,48 @@
 #include "pktinfo.h"
 #include "log.h"
 
-u64 network_and_transport_header_len(struct sk_buff *skb) {
+u64 network_and_transport_header_len(struct sk_buff *skb)
+{
     u64 hdrlen;
     struct iphdr *iph;
     struct tcphdr *tcp;
-    
+
     iph = (struct iphdr *)skb->data;
     hdrlen = iph->ihl * 4;
 
-    switch (iph->protocol) {
-        case IPPROTO_TCP:
-            // tcp = (struct tcphdr *)(skb_transport_header(skb) + (iph->ihl << 2));
-            skb->len -= iph->ihl * 4;
-            skb->data += iph->ihl * 4;
-
-            tcp =  (struct tcphdr *)skb->data;
-            hdrlen += tcp->doff * 4;
-            break;
-        case IPPROTO_UDP:
-            hdrlen +=  8; // udp header len = 8B
-            break;
-        default:
-            break;
+    switch (iph->protocol)
+    {
+    case IPPROTO_TCP:
+        // tcp = (struct tcphdr *)(skb_transport_header(skb) + (iph->ihl << 2));
+        skb->len -= iph->ihl * 4;
+        skb->data += iph->ihl * 4;
+
+        tcp = (struct tcphdr *)skb->data;
+        hdrlen += tcp->doff * 4;
+        break;
+    case IPPROTO_UDP:
+        hdrlen += 8; // udp header len = 8B
+        break;
+    default:
+        break;
     }
 
     return hdrlen;
 }
 
-u64 ip4_rm_header(struct sk_buff *skb, unsigned int hdrlen) {
+u64 ip4_rm_header(struct sk_buff *skb, unsigned int hdrlen)
+{
     struct sk_buff *skb_copy, tmp;
     u64 volume;
 
-    // To make sure cacaluting the len of skb will not move the data & len value 
+    // To make sure cacaluting the len of skb will not move the data & len value
     // of the original skb
     tmp = *skb;
     skb_copy = &tmp;
 
     volume = skb->len;
-    if (hdrlen > 0) {
+    if (hdrlen > 0)
+    {
         // packets with gtp header
         volume -= hdrlen;
         skb_copy->len -= hdrlen;
@@ -63,8 +67,8 @@ u64 ip4_rm_header(struct sk_buff *skb, unsigned int hdrlen) {
 }
 
 struct rtable *ip4_find_route(struct sk_buff *skb, struct iphdr *iph,
-    struct sock *sk, struct net_device *gtp_dev, 
-    __be32 saddr, __be32 daddr, struct flowi4 *fl4)
+                              struct sock *sk, struct net_device *gtp_dev,
+                              __be32 saddr, __be32 daddr, struct flowi4 *fl4)
 {
     struct rtable *rt;
     __be16 df;
@@ -78,13 +82,15 @@ struct rtable *ip4_find_route(struct sk_buff *skb, struct iphdr *iph,
     fl4->flowi4_proto = sk->sk_protocol;
 
     rt = ip_route_output_key(dev_net(gtp_dev), fl4);
-    if (IS_ERR(rt)) {
+    if (IS_ERR(rt))
+    {
         GTP5G_ERR(gtp_dev, "no route to %pI4\n", &iph->daddr);
         gtp_dev->stats.tx_carrier_errors++;
         goto err;
     }
 
-    if (rt->dst.dev == gtp_dev) {
+    if (rt->dst.dev == gtp_dev)
+    {
         GTP5G_ERR(gtp_dev, "circular route to %pI4\n", &iph->daddr);
         gtp_dev->stats.collisions++;
         goto err_rt;
@@ -94,28 +100,31 @@ struct rtable *ip4_find_route(struct sk_buff *skb, struct iphdr *iph,
 
     /* This is similar to tnl_update_pmtu(). */
     df = iph->frag_off;
-    if (df) {
+    if (df)
+    {
         mtu = dst_mtu(&rt->dst) - gtp_dev->hard_header_len -
-            sizeof(struct iphdr) - sizeof(struct udphdr);
+              sizeof(struct iphdr) - sizeof(struct udphdr);
         // GTPv1
         mtu -= sizeof(struct gtpv1_hdr);
     }
-    else {
+    else
+    {
         mtu = dst_mtu(&rt->dst);
     }
 
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 4, 8) || defined(RHEL8)
-       rt->dst.ops->update_pmtu(&rt->dst, NULL, skb, mtu, false);
+    rt->dst.ops->update_pmtu(&rt->dst, NULL, skb, mtu, false);
 #else
-       rt->dst.ops->update_pmtu(&rt->dst, NULL, skb, mtu);
+    rt->dst.ops->update_pmtu(&rt->dst, NULL, skb, mtu);
 #endif
 
     if (!skb_is_gso(skb) && (iph->frag_off & htons(IP_DF)) &&
-        mtu < ntohs(iph->tot_len)) {
+        mtu < ntohs(iph->tot_len))
+    {
         GTP5G_ERR(gtp_dev, "packet too big, fragmentation needed\n");
         memset(IPCB(skb), 0, sizeof(*IPCB(skb)));
         icmp_send(skb, ICMP_DEST_UNREACH, ICMP_FRAG_NEEDED,
-              htonl(mtu));
+                  htonl(mtu));
         goto err_rt;
     }
 
@@ -127,8 +136,8 @@ err:
 }
 
 struct rtable *ip4_find_route_simple(struct sk_buff *skb,
-    struct sock *sk, struct net_device *gtp_dev, 
-    __be32 saddr, __be32 daddr, struct flowi4 *fl4)
+                                     struct sock *sk, struct net_device *gtp_dev,
+                                     __be32 saddr, __be32 daddr, struct flowi4 *fl4)
 {
     struct rtable *rt;
 
@@ -140,15 +149,17 @@ struct rtable *ip4_find_route_simple(struct sk_buff *skb,
     fl4->flowi4_proto = sk->sk_protocol;
 
     rt = ip_route_output_key(dev_net(gtp_dev), fl4);
-    if (IS_ERR(rt)) {
+    if (IS_ERR(rt))
+    {
         GTP5G_ERR(gtp_dev, "no route from %#x to %#x\n", saddr, daddr);
         gtp_dev->stats.tx_carrier_errors++;
         goto err;
     }
 
-    if (rt->dst.dev == gtp_dev) {
-        GTP5G_ERR(gtp_dev, "Packet colllisions from %#x to %#x\n", 
-            saddr, daddr);
+    if (rt->dst.dev == gtp_dev)
+    {
+        GTP5G_ERR(gtp_dev, "Packet colllisions from %#x to %#x\n",
+                  saddr, daddr);
         gtp_dev->stats.collisions++;
         goto err_rt;
     }
@@ -163,7 +174,7 @@ err:
     return ERR_PTR(-ENOENT);
 }
 
-int ip_xmit(struct sk_buff *skb, struct sock *sk, struct net_device *gtp_dev) 
+int ip_xmit(struct sk_buff *skb, struct sock *sk, struct net_device *gtp_dev)
 {
     struct iphdr *iph = ip_hdr(skb);
     struct flowi4 fl4;
@@ -171,7 +182,8 @@ int ip_xmit(struct sk_buff *skb, struct sock *sk, struct net_device *gtp_dev)
     __be32 src;
 
     rt = ip4_find_route_simple(skb, sk, gtp_dev, 0, iph->daddr, &fl4);
-    if (IS_ERR(rt)) {
+    if (IS_ERR(rt))
+    {
         GTP5G_ERR(gtp_dev, "Failed to find route\n");
         return -EBADMSG;
     }
@@ -182,13 +194,15 @@ int ip_xmit(struct sk_buff *skb, struct sock *sk, struct net_device *gtp_dev)
         Support multiple IP address configured on outgoing interface.
      */
     src = inet_select_addr(rt->dst.dev,
-                    rt_nexthop(rt, iph->daddr),
-                    RT_SCOPE_UNIVERSE);
-    if (src != 0) {
+                           rt_nexthop(rt, iph->daddr),
+                           RT_SCOPE_UNIVERSE);
+    if (src != 0)
+    {
         iph->saddr = src;
     }
 
-    if (ip_local_out(dev_net(gtp_dev), sk, skb) < 0) {
+    if (ip_local_out(dev_net(gtp_dev), sk, skb) < 0)
+    {
         GTP5G_ERR(gtp_dev, "Failed to send skb to ip layer\n");
         return -1;
     }
@@ -196,7 +210,7 @@ int ip_xmit(struct sk_buff *skb, struct sock *sk, struct net_device *gtp_dev)
 }
 
 void gtp5g_fwd_emark_skb_ipv4(struct sk_buff *skb,
-    struct net_device *dev, struct gtp5g_emark_pktinfo *epkt_info) 
+                              struct net_device *dev, struct gtp5g_emark_pktinfo *epkt_info)
 {
     struct rtable *rt;
     struct flowi4 fl4;
@@ -213,50 +227,51 @@ void gtp5g_fwd_emark_skb_ipv4(struct sk_buff *skb,
     gtp1->type = GTPV1_MSG_TYPE_EMARK;
     gtp1->tid = epkt_info->teid;
 
-    rt = ip4_find_route_simple(skb, epkt_info->sk, dev, 
-        epkt_info->role_addr /* Src Addr */ ,
-        epkt_info->peer_addr /* Dst Addr*/, 
-        &fl4);
-    if (IS_ERR(rt)) {
+    rt = ip4_find_route_simple(skb, epkt_info->sk, dev,
+                               epkt_info->role_addr /* Src Addr */,
+                               epkt_info->peer_addr /* Dst Addr*/,
+                               &fl4);
+    if (IS_ERR(rt))
+    {
         GTP5G_ERR(dev, "Failed to send GTP-U end-marker due to routing\n");
         dev_kfree_skb(skb);
         return;
     }
 
-    udp_tunnel_xmit_skb(rt, 
-        epkt_info->sk, 
-        skb,
-        fl4.saddr, 
-        fl4.daddr,
-        0,
-        ip4_dst_hoplimit(&rt->dst),
-        0,
-        epkt_info->gtph_port, 
-        epkt_info->gtph_port,
-        true, 
-        true);
+    udp_tunnel_xmit_skb(rt,
+                        epkt_info->sk,
+                        skb,
+                        fl4.saddr,
+                        fl4.daddr,
+                        0,
+                        ip4_dst_hoplimit(&rt->dst),
+                        0,
+                        epkt_info->gtph_port,
+                        epkt_info->gtph_port,
+                        true,
+                        true);
 }
 
 void gtp5g_xmit_skb_ipv4(struct sk_buff *skb, struct gtp5g_pktinfo *pktinfo)
 {
-    udp_tunnel_xmit_skb(pktinfo->rt, 
-        pktinfo->sk,
-        skb,
-        pktinfo->fl4.saddr,
-        pktinfo->fl4.daddr,
-        pktinfo->iph->tos,
-        ip4_dst_hoplimit(&pktinfo->rt->dst),
-        0,
-        pktinfo->gtph_port, 
-        pktinfo->gtph_port,
-        true, 
-        true);
+    udp_tunnel_xmit_skb(pktinfo->rt,
+                        pktinfo->sk,
+                        skb,
+                        pktinfo->fl4.saddr,
+                        pktinfo->fl4.daddr,
+                        pktinfo->iph->tos,
+                        ip4_dst_hoplimit(&pktinfo->rt->dst),
+                        0,
+                        pktinfo->gtph_port,
+                        pktinfo->gtph_port,
+                        true,
+                        true);
 }
 
 inline void gtp5g_set_pktinfo_ipv4(struct gtp5g_pktinfo *pktinfo,
-    struct sock *sk, struct iphdr *iph, struct outer_header_creation *hdr_creation,
-    u8 qfi, u16 seq_number, struct rtable *rt, struct flowi4 *fl4,
-    struct net_device *dev)
+                                   struct sock *sk, struct iphdr *iph, struct outer_header_creation *hdr_creation,
+                                   u8 qfi, u16 seq_number, struct rtable *rt, struct flowi4 *fl4,
+                                   struct net_device *dev)
 {
     pktinfo->sk = sk;
     pktinfo->iph = iph;
@@ -281,16 +296,17 @@ void gtp5g_push_header(struct sk_buff *skb, struct gtp5g_pktinfo *pktinfo)
     int opt_flag = 0;
     int seq_flag = get_seq_enable();
 
-    GTP5G_TRC(NULL, "SKBLen(%u) GTP-U V1(%zu) Opt(%zu) DL_PDU(%zu)\n", 
-        payload_len, sizeof(*gtp1), sizeof(*gtp1opt), sizeof(*dl_pdu_sess));
+    GTP5G_TRC(NULL, "SKBLen(%u) GTP-U V1(%zu) Opt(%zu) DL_PDU(%zu)\n",
+              payload_len, sizeof(*gtp1), sizeof(*gtp1opt), sizeof(*dl_pdu_sess));
 
     pktinfo->gtph_port = pktinfo->hdr_creation->port;
 
     /* Suppport for extension header, sequence number and N-PDU.
      * Update the length field if any of them is available.
      */
-    if (pktinfo->qfi > 0) {
-        ext_flag = 1; 
+    if (pktinfo->qfi > 0)
+    {
+        ext_flag = 1;
 
         /* Push PDU Session container information */
         dl_pdu_sess = skb_push(skb, sizeof(*dl_pdu_sess));
@@ -298,19 +314,21 @@ void gtp5g_push_header(struct sk_buff *skb, struct gtp5g_pktinfo *pktinfo)
         dl_pdu_sess->length = 1;
         dl_pdu_sess->pdu_sess_ctr.type_spare = 0; /* For DL */
         dl_pdu_sess->pdu_sess_ctr.u.dl.ppp_rqi_qfi = pktinfo->qfi;
-        //TODO: PPI
+        // TODO: PPI
         dl_pdu_sess->next_ehdr_type = 0; /* No more extension Header */
-        
+
         opt_flag = 1;
         next_ehdr_type = 0x85; /* PDU Session Container */
     }
 
-    if (seq_flag){
+    if (seq_flag)
+    {
         opt_flag = 1;
         seq_number = htons(pktinfo->seq_number);
     }
 
-    if (opt_flag) {
+    if (opt_flag)
+    {
         /* Push optional header information */
         gtp1opt = skb_push(skb, sizeof(*gtp1opt));
         gtp1opt->seq_number = seq_number;
@@ -328,14 +346,14 @@ void gtp5g_push_header(struct sk_buff *skb, struct gtp5g_pktinfo *pktinfo)
      */
     gtp1 = skb_push(skb, sizeof(*gtp1));
     gtp1->flags = GTPV1; /* v1, GTP-non-prime. */
-    if (ext_flag) 
-        gtp1->flags |= GTPV1_HDR_FLG_EXTHDR; /* v1, Extension header enabled */ 
+    if (ext_flag)
+        gtp1->flags |= GTPV1_HDR_FLG_EXTHDR; /* v1, Extension header enabled */
     if (seq_flag)
         gtp1->flags |= GTPV1_HDR_FLG_SEQ;
     gtp1->type = GTPV1_MSG_TYPE_TPDU;
     gtp1->tid = pktinfo->hdr_creation->teid;
-    gtp1->length = htons(payload_len);       /* Excluded the header length of gtpv1 */
+    gtp1->length = htons(payload_len); /* Excluded the header length of gtpv1 */
 
-    GTP5G_TRC(NULL, "QER Found GTP-U Flg(%u) GTPU-L(%u) SkbLen(%u)\n", 
-        gtp1->flags, ntohs(gtp1->length), skb->len);
+    GTP5G_TRC(NULL, "QER Found GTP-U Flg(%u) GTPU-L(%u) SkbLen(%u)\n",
+              gtp1->flags, ntohs(gtp1->length), skb->len);
 }
diff --git a/src/pfcp/pdr.c b/src/pfcp/pdr.c
index e9d63e4..cefcd40 100644
--- a/src/pfcp/pdr.c
+++ b/src/pfcp/pdr.c
@@ -45,7 +45,8 @@ static void pdr_context_free(struct rcu_head *head)
         kfree(pdr->outer_header_removal);
 
     pdi = pdr->pdi;
-    if (pdi) {
+    if (pdi)
+    {
         if (pdi->ue_addr_ipv4)
             kfree(pdi->ue_addr_ipv4);
         if (pdi->f_teid)
@@ -58,8 +59,10 @@ static void pdr_context_free(struct rcu_head *head)
             kfree(pdr->urr_ids);
 
         sdf = pdi->sdf;
-        if (sdf) {
-            if (sdf->rule) {
+        if (sdf)
+        {
+            if (sdf->rule)
+            {
                 if (sdf->rule->sport)
                     kfree(sdf->rule->sport);
                 if (sdf->rule->dport)
@@ -120,22 +123,26 @@ int unix_sock_client_new(struct pdr *pdr)
     struct sockaddr_un *addr = &pdr->addr_unix;
     int err;
 
-    if (strlen(addr->sun_path) == 0) {
+    if (strlen(addr->sun_path) == 0)
+    {
         return -EINVAL;
     }
 
-    if (pdr_addr_is_netlink(pdr)) {
+    if (pdr_addr_is_netlink(pdr))
+    {
         return 0;
     }
 
     err = sock_create(AF_UNIX, SOCK_DGRAM, 0, psock);
-    if (err) {
+    if (err)
+    {
         return err;
     }
 
     err = (*psock)->ops->connect(*psock, (struct sockaddr *)addr,
-            sizeof(addr->sun_family) + strlen(addr->sun_path), 0);
-    if (err) {
+                                 sizeof(addr->sun_family) + strlen(addr->sun_path), 0);
+    if (err)
+    {
         unix_sock_client_delete(pdr);
         return err;
     }
@@ -165,7 +172,8 @@ struct pdr *find_pdr_by_id(struct gtp5g_dev *gtp, u64 seid, u16 pdr_id)
 
     seid_pdr_id_to_hex_str(seid, pdr_id, seid_pdr_id);
     head = &gtp->pdr_id_hash[str_hashfn(seid_pdr_id) % gtp->hash_size];
-    hlist_for_each_entry_rcu(pdr, head, hlist_id) {
+    hlist_for_each_entry_rcu(pdr, head, hlist_id)
+    {
         if (pdr->seid == seid && pdr->id == pdr_id)
             return pdr;
     }
@@ -185,7 +193,8 @@ static bool ports_match(struct range *match_list, int list_len, __be16 port)
     if (!list_len)
         return true;
 
-    for (i = 0; i < list_len; i++) {
+    for (i = 0; i < list_len; i++)
+    {
         if (match_list[i].start <= port && match_list[i].end >= port)
             return true;
     }
@@ -193,9 +202,9 @@ static bool ports_match(struct range *match_list, int list_len, __be16 port)
 }
 
 static int sdf_filter_match(struct sdf_filter *sdf, struct sk_buff *skb,
-        unsigned int hdrlen, u8 direction)
+                            unsigned int hdrlen, u8 direction)
 {
-    #define IP_PROTO_RESERVED 0xff
+#define IP_PROTO_RESERVED 0xff
     struct iphdr *iph;
     struct ip_filter_rule *rule;
     const __be16 *pptr;
@@ -209,7 +218,8 @@ static int sdf_filter_match(struct sdf_filter *sdf, struct sk_buff *skb,
 
     iph = (struct iphdr *)(skb->data + hdrlen);
 
-    if (sdf->rule) {
+    if (sdf->rule)
+    {
         rule = sdf->rule;
         if (rule->direction != direction)
             goto mismatch;
@@ -223,7 +233,8 @@ static int sdf_filter_match(struct sdf_filter *sdf, struct sk_buff *skb,
         if (!ipv4_match(iph->daddr, rule->dest.s_addr, rule->dmask.s_addr))
             goto mismatch;
 
-        if (rule->sport_num + rule->dport_num > 0) {
+        if (rule->sport_num + rule->dport_num > 0)
+        {
             if (!(pptr = skb_header_pointer(skb, hdrlen + sizeof(struct iphdr), sizeof(_ports), _ports)))
                 goto mismatch;
 
@@ -235,19 +246,19 @@ static int sdf_filter_match(struct sdf_filter *sdf, struct sk_buff *skb,
         }
     }
 
-/*
-    if (sdf->tos_traffic_class)
-        GTP5G_ERR(NULL, "TODO: SDF's ToS traffic class\n");
+    /*
+        if (sdf->tos_traffic_class)
+            GTP5G_ERR(NULL, "TODO: SDF's ToS traffic class\n");
 
-    if (sdf->security_param_idx)
-        GTP5G_ERR(NULL, "TODO: SDF's Security parameter index\n");
+        if (sdf->security_param_idx)
+            GTP5G_ERR(NULL, "TODO: SDF's Security parameter index\n");
 
-    if (sdf->flow_label)
-        GTP5G_ERR(NULL, "TODO: SDF's Flow label\n");
+        if (sdf->flow_label)
+            GTP5G_ERR(NULL, "TODO: SDF's Flow label\n");
 
-    if (sdf->bi_id)
-        GTP5G_ERR(NULL, "TODO: SDF's SDF filter id\n");
-*/
+        if (sdf->bi_id)
+            GTP5G_ERR(NULL, "TODO: SDF's SDF filter id\n");
+    */
 
     return 1;
 mismatch:
@@ -255,7 +266,7 @@ mismatch:
 }
 
 struct pdr *pdr_find_by_gtp1u(struct gtp5g_dev *gtp, struct sk_buff *skb,
-        unsigned int hdrlen, u32 teid, u8 type)
+                              unsigned int hdrlen, u32 teid, u8 type)
 {
 #ifdef MATCH_IP
     struct iphdr *outer_iph;
@@ -272,7 +283,8 @@ struct pdr *pdr_find_by_gtp1u(struct gtp5g_dev *gtp, struct sk_buff *skb,
     if (ntohs(skb->protocol) != ETH_P_IP)
         return NULL;
 
-    if (type == GTPV1_MSG_TYPE_TPDU) {
+    if (type == GTPV1_MSG_TYPE_TPDU)
+    {
         if (!pskb_may_pull(skb, hdrlen + sizeof(struct iphdr)))
             return NULL;
         iph = (struct iphdr *)(skb->data + hdrlen);
@@ -280,7 +292,8 @@ struct pdr *pdr_find_by_gtp1u(struct gtp5g_dev *gtp, struct sk_buff *skb,
     }
 
     head = &gtp->i_teid_hash[u32_hashfn(teid) % gtp->hash_size];
-    hlist_for_each_entry_rcu(pdr, head, hlist_i_teid) {
+    hlist_for_each_entry_rcu(pdr, head, hlist_i_teid)
+    {
         pdi = pdr->pdi;
         if (!pdi)
             continue;
@@ -292,17 +305,17 @@ struct pdr *pdr_find_by_gtp1u(struct gtp5g_dev *gtp, struct sk_buff *skb,
         if (type != GTPV1_MSG_TYPE_TPDU)
             return pdr;
 
-        // check outer IP dest addr to distinguish between N3 and N9 packet whil e act as i-upf
+            // check outer IP dest addr to distinguish between N3 and N9 packet whil e act as i-upf
 #ifdef MATCH_IP
-    #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
-            outer_iph = (struct iphdr *)(skb->head + skb->network_header);
-            if (!(pdi->f_teid && pdi->f_teid->gtpu_addr_ipv4.s_addr == outer_iph->daddr))
-                continue;
-    #else
-            outer_iph = (struct iphdr *)(skb->network_header);
-            if (!(pdi->f_teid && pdi->f_teid->gtpu_addr_ipv4.s_addr == outer_iph->daddr))
-                continue;
-    #endif
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 0, 0)
+        outer_iph = (struct iphdr *)(skb->head + skb->network_header);
+        if (!(pdi->f_teid && pdi->f_teid->gtpu_addr_ipv4.s_addr == outer_iph->daddr))
+            continue;
+#else
+        outer_iph = (struct iphdr *)(skb->network_header);
+        if (!(pdi->f_teid && pdi->f_teid->gtpu_addr_ipv4.s_addr == outer_iph->daddr))
+            continue;
+#endif
 #endif
         if (pdi->ue_addr_ipv4)
             if (!(pdr->af == AF_INET && target_addr && *target_addr == pdi->ue_addr_ipv4->s_addr))
@@ -312,7 +325,7 @@ struct pdr *pdr_find_by_gtp1u(struct gtp5g_dev *gtp, struct sk_buff *skb,
             if (!sdf_filter_match(pdi->sdf, skb, hdrlen, GTP5G_SDF_FILTER_OUT))
                 continue;
 
-        GTP5G_INF(NULL, "Match PDR ID:%d\n", pdr->id);
+        GTP5G_TRC(NULL, "Match PDR ID:%d\n", pdr->id);
 
         return pdr;
     }
@@ -321,7 +334,7 @@ struct pdr *pdr_find_by_gtp1u(struct gtp5g_dev *gtp, struct sk_buff *skb,
 }
 
 struct pdr *pdr_find_by_ipv4(struct gtp5g_dev *gtp, struct sk_buff *skb,
-        unsigned int hdrlen, __be32 addr)
+                             unsigned int hdrlen, __be32 addr)
 {
     struct hlist_head *head;
     struct pdr *pdr;
@@ -329,7 +342,8 @@ struct pdr *pdr_find_by_ipv4(struct gtp5g_dev *gtp, struct sk_buff *skb,
 
     head = &gtp->addr_hash[ipv4_hashfn(addr) % gtp->hash_size];
 
-    hlist_for_each_entry_rcu(pdr, head, hlist_addr) {
+    hlist_for_each_entry_rcu(pdr, head, hlist_addr)
+    {
         pdi = pdr->pdi;
 
         // TODO: Move the value we check into first level
@@ -375,10 +389,12 @@ void pdr_update_hlist_table(struct pdr *pdr, struct gtp5g_dev *gtp)
         return;
 
     f_teid = pdi->f_teid;
-    if (f_teid) {
+    if (f_teid)
+    {
         last_ppdr = NULL;
         head = &gtp->i_teid_hash[u32_hashfn(f_teid->teid) % gtp->hash_size];
-        hlist_for_each_entry_rcu(ppdr, head, hlist_i_teid) {
+        hlist_for_each_entry_rcu(ppdr, head, hlist_i_teid)
+        {
             if (pdr->precedence > ppdr->precedence)
                 last_ppdr = ppdr;
             else
@@ -388,10 +404,13 @@ void pdr_update_hlist_table(struct pdr *pdr, struct gtp5g_dev *gtp)
             hlist_add_head_rcu(&pdr->hlist_i_teid, head);
         else
             hlist_add_behind_rcu(&pdr->hlist_i_teid, &last_ppdr->hlist_i_teid);
-    } else if (pdi->ue_addr_ipv4) {
+    }
+    else if (pdi->ue_addr_ipv4)
+    {
         last_ppdr = NULL;
         head = &gtp->addr_hash[u32_hashfn(pdi->ue_addr_ipv4->s_addr) % gtp->hash_size];
-        hlist_for_each_entry_rcu(ppdr, head, hlist_addr) {
+        hlist_for_each_entry_rcu(ppdr, head, hlist_addr)
+        {
             if (pdr->precedence > ppdr->precedence)
                 last_ppdr = ppdr;
             else
diff --git a/src/proc.c b/src/proc.c
index b725aee..41c67d6 100644
--- a/src/proc.c
+++ b/src/proc.c
@@ -11,74 +11,78 @@
 #include "util.h"
 
 struct list_head proc_gtp5g_dev;
-struct proc_gtp5g_pdr {
-    u16     id;
-    u64     seid;
-    u32     precedence;
-    u8      ohr;
-    u32     role_addr4;
-
-    u32     pdi_ue_addr4;
-    u32     pdi_fteid;
-    u32     pdi_gtpu_addr4;
-    
-    u32     far_id;
-    u32     *qer_ids;
-    u32     qer_num;
-
-    u32     *urr_ids;
-    u32     urr_num;
-
-    u64     ul_drop_cnt;
-    u64     dl_drop_cnt;
+struct proc_gtp5g_pdr
+{
+    u16 id;
+    u64 seid;
+    u32 precedence;
+    u8 ohr;
+    u32 role_addr4;
+
+    u32 pdi_ue_addr4;
+    u32 pdi_fteid;
+    u32 pdi_gtpu_addr4;
+
+    u32 far_id;
+    u32 *qer_ids;
+    u32 qer_num;
+
+    u32 *urr_ids;
+    u32 urr_num;
+
+    u64 ul_drop_cnt;
+    u64 dl_drop_cnt;
 
     /* Packet Statistics */
-    u64     ul_pkt_cnt;
-    u64     dl_pkt_cnt;
-    u64     ul_byte_cnt;
-    u64     dl_byte_cnt;
+    u64 ul_pkt_cnt;
+    u64 dl_pkt_cnt;
+    u64 ul_byte_cnt;
+    u64 dl_byte_cnt;
 };
 
-struct proc_gtp5g_far {
-    u32     id;
-    u64     seid;
-    u16     action;
-
-    //OHC
-    u16     description;
-    u32     teid; 
-    u32     peer_addr4;
+struct proc_gtp5g_far
+{
+    u32 id;
+    u64 seid;
+    u16 action;
+
+    // OHC
+    u16 description;
+    u32 teid;
+    u32 peer_addr4;
 };
 
-struct proc_gtp5g_qer {
-    u32     id;
-    u64     seid;
-    u8      qfi;
+struct proc_gtp5g_qer
+{
+    u32 id;
+    u64 seid;
+    u8 qfi;
 };
 
-struct proc_gtp5g_urr {
-    u32     id;
-    u64     seid;
-    u8      method;
-    u32     trigger;
-    u32     period;
-    u8      info;
-
-    u8      volth_flag;
-    u64     volth_tolvol;
-    u64     volth_ulvol;
-    u64     volth_dlvol;
-
-    u8      volqu_flag;
-    u64     volqu_tolvol;
-    u64     volqu_ulvol;
-    u64     volqu_dlvol;
-
-    s64     start_time;
-    s64     end_time;
+struct proc_gtp5g_urr
+{
+    u32 id;
+    u64 seid;
+    u8 method;
+    u32 trigger;
+    u32 period;
+    u8 info;
+
+    u8 volth_flag;
+    u64 volth_tolvol;
+    u64 volth_ulvol;
+    u64 volth_dlvol;
+
+    u8 volqu_flag;
+    u64 volqu_tolvol;
+    u64 volqu_ulvol;
+    u64 volqu_dlvol;
+
+    s64 start_time;
+    s64 end_time;
 };
 
-struct proc_gtp5g_qos 
+struct proc_gtp5g_qos
 {
     bool qos_enable;
 };
@@ -109,15 +113,17 @@ u32 proc_far_id = 0;
 u32 proc_qer_id = 0;
 u32 proc_urr_id = 0;
 
-struct list_head * get_proc_gtp5g_dev_list_head(){
+struct list_head *get_proc_gtp5g_dev_list_head()
+{
     return &proc_gtp5g_dev;
 }
 
-void init_proc_gtp5g_dev_list(){
+void init_proc_gtp5g_dev_list()
+{
     INIT_LIST_HEAD(&proc_gtp5g_dev);
 }
 
-static int gtp5g_dbg_read(struct seq_file *s, void *v) 
+static int gtp5g_dbg_read(struct seq_file *s, void *v)
 {
     seq_printf(s, "gtp5g kerenl debug level range: 0~4\n");
     seq_printf(s, "\t 0 -> Logging\n");
@@ -130,28 +136,31 @@ static int gtp5g_dbg_read(struct seq_file *s, void *v)
 }
 
 static ssize_t proc_dbg_write(struct file *filp, const char __user *buffer,
-    size_t len, loff_t *dptr) 
+                              size_t len, loff_t *dptr)
 {
     char buf[16];
     unsigned long buf_len = min(len, sizeof(buf) - 1);
     int dbg;
 
-    if (copy_from_user(buf, buffer, buf_len)) {
+    if (copy_from_user(buf, buffer, buf_len))
+    {
         GTP5G_ERR(NULL, "Failed to read buffer: %s\n", buffer);
         goto err;
     }
-    
+
     buf[buf_len] = 0;
-    if (sscanf(buf, "%d", &dbg) != 1) {
+    if (sscanf(buf, "%d", &dbg) != 1)
+    {
         GTP5G_ERR(NULL, "Failed to read debug level: %s\n", buffer);
         goto err;
     }
-  
-    if (dbg < 0 || dbg > 4) {
+
+    if (dbg < 0 || dbg > 4)
+    {
         GTP5G_ERR(NULL, "Failed to set debug level: %d <0 or >4\n", dbg);
         goto err;
     }
-    
+
     set_dbg_lvl(dbg);
     return strnlen(buf, buf_len);
 err:
@@ -166,7 +175,8 @@ static int proc_dbg_read(struct inode *inode, struct file *file)
 static void set_pdr_qer_ids(char *pdr_qer_ids, struct proc_gtp5g_pdr *proc_pdr)
 {
     int i = 0, len = 0;
-    for (i = 0; i < proc_pdr->qer_num; i++) {
+    for (i = 0; i < proc_pdr->qer_num; i++)
+    {
         len += sprintf(&pdr_qer_ids[len], "0x%x, ", proc_pdr->qer_ids[i]);
     }
 }
@@ -174,12 +184,13 @@ static void set_pdr_qer_ids(char *pdr_qer_ids, struct proc_gtp5g_pdr *proc_pdr)
 static void set_pdr_urr_ids(char *pdr_urr_ids, struct proc_gtp5g_pdr *proc_pdr)
 {
     int i = 0, len = 0;
-    for (i = 0; i < proc_pdr->urr_num; i++) {
+    for (i = 0; i < proc_pdr->urr_num; i++)
+    {
         len += sprintf(&pdr_urr_ids[len], "0x%x, ", proc_pdr->urr_ids[i]);
     }
 }
 
-static int gtp5g_pdr_read(struct seq_file *s, void *v) 
+static int gtp5g_pdr_read(struct seq_file *s, void *v)
 {
     char role_addr[35];
     char pdi_ue_addr[35];
@@ -187,11 +198,12 @@ static int gtp5g_pdr_read(struct seq_file *s, void *v)
     char pdr_qer_ids[64];
     char pdr_urr_ids[64];
 
-    if (!proc_pdr_id) {
+    if (!proc_pdr_id)
+    {
         seq_printf(s, "Given PDR ID does not exists\n");
         return -1;
     }
-    
+
     seq_printf(s, "PDR: \n");
     seq_printf(s, "\t SEID : %llu\n", proc_pdr.seid);
     seq_printf(s, "\t ID : %u\n", proc_pdr.id);
@@ -218,13 +230,14 @@ static int gtp5g_pdr_read(struct seq_file *s, void *v)
     return 0;
 }
 
-static int gtp5g_far_read(struct seq_file *s, void *v) 
+static int gtp5g_far_read(struct seq_file *s, void *v)
 {
-    if (!proc_far_id) {
+    if (!proc_far_id)
+    {
         seq_printf(s, "Given FAR ID does not exists\n");
         return -1;
     }
-    
+
     seq_printf(s, "FAR: \n");
     seq_printf(s, "\t SEID : %llu\n", proc_far.seid);
     seq_printf(s, "\t ID : %u\n", proc_far.id);
@@ -235,13 +248,14 @@ static int gtp5g_far_read(struct seq_file *s, void *v)
     return 0;
 }
 
-static int gtp5g_qer_read(struct seq_file *s, void *v) 
+static int gtp5g_qer_read(struct seq_file *s, void *v)
 {
-    if (!proc_qer_id) {
+    if (!proc_qer_id)
+    {
         seq_printf(s, "Given QER ID does not exists\n");
         return -1;
     }
-    
+
     seq_printf(s, "QER: \n");
     seq_printf(s, "\t SEID : %llu\n", proc_qer.seid);
     seq_printf(s, "\t ID : %u\n", proc_qer.id);
@@ -251,7 +265,8 @@ static int gtp5g_qer_read(struct seq_file *s, void *v)
 
 static int gtp5g_urr_read(struct seq_file *s, void *v)
 {
-    if (!proc_urr_id) {
+    if (!proc_urr_id)
+    {
         seq_printf(s, "Given URR ID does not exists\n");
         return -1;
     }
@@ -287,23 +302,25 @@ static int gtp5g_qos_read(struct seq_file *s, void *v)
 }
 
 static ssize_t proc_qos_write(struct file *filp, const char __user *buffer,
-    size_t len, loff_t *dptr) 
+                              size_t len, loff_t *dptr)
 {
     char buf[16];
     unsigned long buf_len = min(len, sizeof(buf) - 1);
     int qos_enable;
 
-    if (copy_from_user(buf, buffer, buf_len)) {
+    if (copy_from_user(buf, buffer, buf_len))
+    {
         GTP5G_ERR(NULL, "Failed to read buffer: %s\n", buffer);
         goto err;
     }
-    
+
     buf[buf_len] = 0;
-    if (sscanf(buf, "%d", &qos_enable) != 1) {
+    if (sscanf(buf, "%d", &qos_enable) != 1)
+    {
         GTP5G_ERR(NULL, "Failed to read qos enable setting: %s\n", buffer);
         goto err;
     }
-     
+
     set_qos_enable(qos_enable);
     GTP5G_TRC(NULL, "qos enable:%d", get_qos_enable());
     return strnlen(buf, buf_len);
@@ -311,7 +328,6 @@ err:
     return -1;
 }
 
-
 static int gtp5g_seq_read(struct seq_file *s, void *v)
 {
     GTP5G_TRC(NULL, "gtp5g_seq_read");
@@ -320,23 +336,25 @@ static int gtp5g_seq_read(struct seq_file *s, void *v)
 }
 
 static ssize_t proc_seq_write(struct file *filp, const char __user *buffer,
-    size_t len, loff_t *dptr) 
+                              size_t len, loff_t *dptr)
 {
     char buf[16];
     unsigned long buf_len = min(len, sizeof(buf) - 1);
     int seq_enable;
 
-    if (copy_from_user(buf, buffer, buf_len)) {
+    if (copy_from_user(buf, buffer, buf_len))
+    {
         GTP5G_ERR(NULL, "Failed to read buffer: %s\n", buffer);
         goto err;
     }
-    
+
     buf[buf_len] = 0;
-    if (sscanf(buf, "%d", &seq_enable) != 1) {
+    if (sscanf(buf, "%d", &seq_enable) != 1)
+    {
         GTP5G_ERR(NULL, "Failed to read seq enable setting: %s\n", buffer);
         goto err;
     }
-     
+
     set_seq_enable(seq_enable);
     GTP5G_TRC(NULL, "seq enable:%d", get_seq_enable());
     return strnlen(buf, buf_len);
@@ -345,7 +363,7 @@ err:
 }
 
 static ssize_t proc_pdr_write(struct file *filp, const char __user *buffer,
-    size_t len, loff_t *dptr)
+                              size_t len, loff_t *dptr)
 {
     char buf[128], dev_name[32];
     u8 found = 0;
@@ -353,30 +371,36 @@ static ssize_t proc_pdr_write(struct file *filp, const char __user *buffer,
     struct pdr *pdr;
     struct gtp5g_dev *gtp;
 
-    if (copy_from_user(buf, buffer, buf_len)) {
+    if (copy_from_user(buf, buffer, buf_len))
+    {
         GTP5G_ERR(NULL, "Failed to read buffer: %s\n", buf);
         goto err;
     }
 
     buf[buf_len] = 0;
-    if (sscanf(buf, "%s %llu %hu", dev_name, &proc_seid, &proc_pdr_id) != 3) {
+    if (sscanf(buf, "%s %llu %hu", dev_name, &proc_seid, &proc_pdr_id) != 3)
+    {
         GTP5G_ERR(NULL, "proc write of PDR Dev & ID: %s is not valid\n", buf);
         goto err;
     }
 
-    list_for_each_entry_rcu(gtp, &proc_gtp5g_dev, proc_list) {
-        if (strcmp(dev_name, netdev_name(gtp->dev)) == 0) {
+    list_for_each_entry_rcu(gtp, &proc_gtp5g_dev, proc_list)
+    {
+        if (strcmp(dev_name, netdev_name(gtp->dev)) == 0)
+        {
             found = 1;
             break;
         }
     }
-    if (!found) {
+    if (!found)
+    {
         GTP5G_ERR(NULL, "Given dev: %s not exists\n", dev_name);
         goto err;
     }
 
     pdr = find_pdr_by_id(gtp, proc_seid, proc_pdr_id);
-    if (!pdr) {
+    if (!pdr)
+    {
         GTP5G_ERR(NULL, "Given SEID : %llu PDR ID : %u not exists\n", proc_seid, proc_pdr_id);
         goto err;
     }
@@ -386,16 +410,18 @@ static ssize_t proc_pdr_write(struct file *filp, const char __user *buffer,
     proc_pdr.seid = pdr->seid;
     proc_pdr.precedence = pdr->precedence;
 
-    if (pdr->outer_header_removal) 
+    if (pdr->outer_header_removal)
         proc_pdr.ohr = *pdr->outer_header_removal;
-    
+
     if (pdr->role_addr_ipv4.s_addr)
         proc_pdr.role_addr4 = pdr->role_addr_ipv4.s_addr;
-    
-    if (pdr->pdi) {
-        if (pdr->pdi->ue_addr_ipv4) 
+
+    if (pdr->pdi)
+    {
+        if (pdr->pdi->ue_addr_ipv4)
             proc_pdr.pdi_ue_addr4 = pdr->pdi->ue_addr_ipv4->s_addr;
-        if (pdr->pdi->f_teid) {
+        if (pdr->pdi->f_teid)
+        {
             proc_pdr.pdi_fteid = pdr->pdi->f_teid->teid;
             proc_pdr.pdi_gtpu_addr4 = pdr->pdi->f_teid->gtpu_addr_ipv4.s_addr;
         }
@@ -404,12 +430,14 @@ static ssize_t proc_pdr_write(struct file *filp, const char __user *buffer,
     if (pdr->far_id)
         proc_pdr.far_id = *pdr->far_id;
 
-    if (pdr->qer_ids) {
+    if (pdr->qer_ids)
+    {
         proc_pdr.qer_ids = pdr->qer_ids;
         proc_pdr.qer_num = pdr->qer_num;
     }
 
-    if (pdr->urr_ids) {
+    if (pdr->urr_ids)
+    {
         proc_pdr.urr_ids = pdr->urr_ids;
         proc_pdr.urr_num = pdr->urr_num;
     }
@@ -429,7 +457,7 @@ err:
 }
 
 static ssize_t proc_far_write(struct file *filp, const char __user *buffer,
-    size_t len, loff_t *dptr) 
+                              size_t len, loff_t *dptr)
 {
     char buf[128], dev_name[32];
     u8 found = 0;
@@ -438,30 +466,36 @@ static ssize_t proc_far_write(struct file *filp, const char __user *buffer,
     struct gtp5g_dev *gtp;
     struct forwarding_parameter *fwd_param;
 
-    if (copy_from_user(buf, buffer, buf_len)) {
+    if (copy_from_user(buf, buffer, buf_len))
+    {
         GTP5G_ERR(NULL, "Failed to read buffer: %s\n", buf);
         goto err;
     }
 
     buf[buf_len] = 0;
-    if (sscanf(buf, "%s %llu %u", dev_name, &proc_seid, &proc_far_id) != 3) {
+    if (sscanf(buf, "%s %llu %u", dev_name, &proc_seid, &proc_far_id) != 3)
+    {
         GTP5G_ERR(NULL, "proc write of FAR Dev & ID: %s is not valid\n", buf);
         goto err;
     }
 
-    list_for_each_entry_rcu(gtp, &proc_gtp5g_dev, proc_list) {
-        if (strcmp(dev_name, netdev_name(gtp->dev)) == 0) {
+    list_for_each_entry_rcu(gtp, &proc_gtp5g_dev, proc_list)
+    {
+        if (strcmp(dev_name, netdev_name(gtp->dev)) == 0)
+        {
             found = 1;
             break;
         }
     }
-    if (!found) {
+    if (!found)
+    {
         GTP5G_ERR(NULL, "Given dev: %s not exists\n", dev_name);
         goto err;
     }
 
     far = find_far_by_id(gtp, proc_seid, proc_far_id);
-    if (!far) {
+    if (!far)
+    {
         GTP5G_ERR(NULL, "Given FAR ID : %u not exists\n", proc_far_id);
         goto err;
     }
@@ -472,8 +506,10 @@ static ssize_t proc_far_write(struct file *filp, const char __user *buffer,
     proc_far.action = far->action;
 
     fwd_param = rcu_dereference(far->fwd_param);
-    if (fwd_param) {
-        if (fwd_param->hdr_creation) {
+    if (fwd_param)
+    {
+        if (fwd_param->hdr_creation)
+        {
             proc_far.description = fwd_param->hdr_creation->description;
             proc_far.teid = fwd_param->hdr_creation->teid;
             proc_far.peer_addr4 = fwd_param->hdr_creation->peer_addr_ipv4.s_addr;
@@ -487,7 +523,7 @@ err:
 }
 
 static ssize_t proc_qer_write(struct file *filp, const char __user *buffer,
-    size_t len, loff_t *dptr) 
+                              size_t len, loff_t *dptr)
 {
     char buf[128], dev_name[32];
     u8 found = 0;
@@ -495,30 +531,36 @@ static ssize_t proc_qer_write(struct file *filp, const char __user *buffer,
     struct qer *qer;
     struct gtp5g_dev *gtp;
 
-    if (copy_from_user(buf, buffer, buf_len)) {
+    if (copy_from_user(buf, buffer, buf_len))
+    {
         GTP5G_ERR(NULL, "Failed to read buffer: %s\n", buf);
         goto err;
     }
 
     buf[buf_len] = 0;
-    if (sscanf(buf, "%s %llu %u", dev_name, &proc_seid, &proc_qer_id) != 3) {
+    if (sscanf(buf, "%s %llu %u", dev_name, &proc_seid, &proc_qer_id) != 3)
+    {
         GTP5G_ERR(NULL, "proc write of QER Dev & ID: %s is not valid\n", buf);
         goto err;
     }
 
-    list_for_each_entry_rcu(gtp, &proc_gtp5g_dev, proc_list) {
-        if (strcmp(dev_name, netdev_name(gtp->dev)) == 0) {
+    list_for_each_entry_rcu(gtp, &proc_gtp5g_dev, proc_list)
+    {
+        if (strcmp(dev_name, netdev_name(gtp->dev)) == 0)
+        {
             found = 1;
             break;
         }
     }
-    if (!found) {
+    if (!found)
+    {
         GTP5G_ERR(NULL, "Given dev: %s not exists\n", dev_name);
         goto err;
     }
 
     qer = find_qer_by_id(gtp, proc_seid, proc_qer_id);
-    if (!qer) {
+    if (!qer)
+    {
         GTP5G_ERR(NULL, "Given QER ID : %u not exists\n", proc_qer_id);
         goto err;
     }
@@ -535,7 +577,7 @@ err:
 }
 
 static ssize_t proc_urr_write(struct file *filp, const char __user *buffer,
-    size_t len, loff_t *dptr) 
+                              size_t len, loff_t *dptr)
 {
     char buf[128], dev_name[32];
     u8 found = 0;
@@ -543,30 +585,36 @@ static ssize_t proc_urr_write(struct file *filp, const char __user *buffer,
     struct urr *urr;
     struct gtp5g_dev *gtp;
 
-    if (copy_from_user(buf, buffer, buf_len)) {
+    if (copy_from_user(buf, buffer, buf_len))
+    {
         GTP5G_ERR(NULL, "Failed to read buffer: %s\n", buf);
         goto err;
     }
 
     buf[buf_len] = 0;
-    if (sscanf(buf, "%s %llu %u", dev_name, &proc_seid, &proc_urr_id) != 3) {
+    if (sscanf(buf, "%s %llu %u", dev_name, &proc_seid, &proc_urr_id) != 3)
+    {
         GTP5G_ERR(NULL, "proc write of URR Dev & ID: %s is not valid\n", buf);
         goto err;
     }
 
-    list_for_each_entry_rcu(gtp, &proc_gtp5g_dev, proc_list) {
-        if (strcmp(dev_name, netdev_name(gtp->dev)) == 0) {
+    list_for_each_entry_rcu(gtp, &proc_gtp5g_dev, proc_list)
+    {
+        if (strcmp(dev_name, netdev_name(gtp->dev)) == 0)
+        {
             found = 1;
             break;
         }
     }
-    if (!found) {
+    if (!found)
+    {
         GTP5G_ERR(NULL, "Given dev: %s not exists\n", dev_name);
         goto err;
     }
 
     urr = find_urr_by_id(gtp, proc_seid, proc_urr_id);
-    if (!urr) {
+    if (!urr)
+    {
         GTP5G_ERR(NULL, "Given URR ID : %u not exists\n", proc_urr_id);
         goto err;
     }
@@ -638,12 +686,12 @@ static const struct proc_ops proc_gtp5g_dbg_ops = {
 };
 #else
 static const struct file_operations proc_gtp5g_dbg_ops = {
-    .owner      = THIS_MODULE,
-    .open       = proc_dbg_read,
-    .read       = seq_read,
-    .write      = proc_dbg_write,
-    .llseek     = seq_lseek,
-    .release    = single_release,
+    .owner = THIS_MODULE,
+    .open = proc_dbg_read,
+    .read = seq_read,
+    .write = proc_dbg_write,
+    .llseek = seq_lseek,
+    .release = single_release,
 };
 #endif
 
@@ -657,12 +705,12 @@ static const struct proc_ops proc_gtp5g_pdr_ops = {
 };
 #else
 static const struct file_operations proc_gtp5g_pdr_ops = {
-    .owner      = THIS_MODULE,
-    .open       = proc_pdr_read,
-    .read       = seq_read,
-    .write      = proc_pdr_write,
-    .llseek     = seq_lseek,
-    .release    = single_release,
+    .owner = THIS_MODULE,
+    .open = proc_pdr_read,
+    .read = seq_read,
+    .write = proc_pdr_write,
+    .llseek = seq_lseek,
+    .release = single_release,
 };
 #endif
 
@@ -676,12 +724,12 @@ static const struct proc_ops proc_gtp5g_far_ops = {
 };
 #else
 static const struct file_operations proc_gtp5g_far_ops = {
-    .owner      = THIS_MODULE,
-    .open       = proc_far_read,
-    .read       = seq_read,
-    .write      = proc_far_write,
-    .llseek     = seq_lseek,
-    .release    = single_release,
+    .owner = THIS_MODULE,
+    .open = proc_far_read,
+    .read = seq_read,
+    .write = proc_far_write,
+    .llseek = seq_lseek,
+    .release = single_release,
 };
 #endif
 
@@ -695,12 +743,12 @@ static const struct proc_ops proc_gtp5g_qer_ops = {
 };
 #else
 static const struct file_operations proc_gtp5g_qer_ops = {
-    .owner      = THIS_MODULE,
-    .open       = proc_qer_read,
-    .read       = seq_read,
-    .write      = proc_qer_write,
-    .llseek     = seq_lseek,
-    .release    = single_release,
+    .owner = THIS_MODULE,
+    .open = proc_qer_read,
+    .read = seq_read,
+    .write = proc_qer_write,
+    .llseek = seq_lseek,
+    .release = single_release,
 };
 #endif
 
@@ -714,12 +762,12 @@ static const struct proc_ops proc_gtp5g_urr_ops = {
 };
 #else
 static const struct file_operations proc_gtp5g_urr_ops = {
-    .owner      = THIS_MODULE,
-    .open       = proc_urr_read,
-    .read       = seq_read,
-    .write      = proc_urr_write,
-    .llseek     = seq_lseek,
-    .release    = single_release,
+    .owner = THIS_MODULE,
+    .open = proc_urr_read,
+    .read = seq_read,
+    .write = proc_urr_write,
+    .llseek = seq_lseek,
+    .release = single_release,
 };
 #endif
 
@@ -733,12 +781,12 @@ static const struct proc_ops proc_gtp5g_qos_ops = {
 };
 #else
 static const struct file_operations proc_gtp5g_qos_ops = {
-    .owner      = THIS_MODULE,
-    .open       = proc_qos_read,
-    .read       = seq_read,
-    .write      = proc_qos_write,
-    .llseek     = seq_lseek,
-    .release    = single_release,
+    .owner = THIS_MODULE,
+    .open = proc_qos_read,
+    .read = seq_read,
+    .write = proc_qos_write,
+    .llseek = seq_lseek,
+    .release = single_release,
 };
 #endif
 
@@ -752,87 +800,95 @@ static const struct proc_ops proc_gtp5g_seq_ops = {
 };
 #else
 static const struct file_operations proc_gtp5g_seq_ops = {
-    .owner      = THIS_MODULE,
-    .open       = proc_seq_read,
-    .read       = seq_read,
-    .write      = proc_seq_write,
-    .llseek     = seq_lseek,
-    .release    = single_release,
+    .owner = THIS_MODULE,
+    .open = proc_seq_read,
+    .read = seq_read,
+    .write = proc_seq_write,
+    .llseek = seq_lseek,
+    .release = single_release,
 };
 #endif
 
 int create_proc(void)
 {
     proc_gtp5g = proc_mkdir("gtp5g", NULL);
-    if (!proc_gtp5g) {
+    if (!proc_gtp5g)
+    {
         GTP5G_ERR(NULL, "Failed to create /proc/gtp5g\n");
     }
 
     proc_gtp5g_dbg = proc_create("dbg", (S_IFREG | S_IRUGO | S_IWUGO),
-        proc_gtp5g, &proc_gtp5g_dbg_ops);
-    if (!proc_gtp5g_dbg) {
+                                 proc_gtp5g, &proc_gtp5g_dbg_ops);
+    if (!proc_gtp5g_dbg)
+    {
         GTP5G_ERR(NULL, "Failed to create /proc/gtp5g/dbg\n");
         goto remove_gtp5g_proc;
     }
 
     proc_gtp5g_pdr = proc_create("pdr", (S_IFREG | S_IRUGO | S_IWUGO),
-        proc_gtp5g, &proc_gtp5g_pdr_ops);
-    if (!proc_gtp5g_pdr) {
+                                 proc_gtp5g, &proc_gtp5g_pdr_ops);
+    if (!proc_gtp5g_pdr)
+    {
         GTP5G_ERR(NULL, "Failed to create /proc/gtp5g/pdr\n");
         goto remove_dbg_proc;
     }
 
     proc_gtp5g_far = proc_create("far", (S_IFREG | S_IRUGO | S_IWUGO),
-        proc_gtp5g, &proc_gtp5g_far_ops);
-    if (!proc_gtp5g_far) {
+                                 proc_gtp5g, &proc_gtp5g_far_ops);
+    if (!proc_gtp5g_far)
+    {
         GTP5G_ERR(NULL, "Failed to create /proc/gtp5g/far\n");
         goto remove_pdr_proc;
     }
 
     proc_gtp5g_qer = proc_create("qer", (S_IFREG | S_IRUGO | S_IWUGO),
-        proc_gtp5g, &proc_gtp5g_qer_ops);
-    if (!proc_gtp5g_qer) {
+                                 proc_gtp5g, &proc_gtp5g_qer_ops);
+    if (!proc_gtp5g_qer)
+    {
         GTP5G_ERR(NULL, "Failed to create /proc/gtp5g/qer\n");
         goto remove_far_proc;
     }
 
     proc_gtp5g_urr = proc_create("urr", (S_IFREG | S_IRUGO | S_IWUGO),
-        proc_gtp5g, &proc_gtp5g_urr_ops);
-    if (!proc_gtp5g_urr) {
+                                 proc_gtp5g, &proc_gtp5g_urr_ops);
+    if (!proc_gtp5g_urr)
+    {
         GTP5G_ERR(NULL, "Failed to create /proc/gtp5g/urr\n");
         goto remove_qer_proc;
     }
 
     proc_gtp5g_qos = proc_create("qos", (S_IFREG | S_IRUGO | S_IWUGO),
-        proc_gtp5g, &proc_gtp5g_qos_ops);
-    if (!proc_gtp5g_qos) {
+                                 proc_gtp5g, &proc_gtp5g_qos_ops);
+    if (!proc_gtp5g_qos)
+    {
         GTP5G_ERR(NULL, "Failed to create /proc/gtp5g/qos\n");
         goto remove_urr_proc;
     }
 
     proc_gtp5g_seq = proc_create("seq", (S_IFREG | S_IRUGO | S_IWUGO),
-        proc_gtp5g, &proc_gtp5g_seq_ops);
-    if (!proc_gtp5g_seq) {
+                                 proc_gtp5g, &proc_gtp5g_seq_ops);
+    if (!proc_gtp5g_seq)
+    {
         GTP5G_ERR(NULL, "Failed to create /proc/gtp5g/seq\n");
         goto remove_qos_proc;
     }
 
     return 0;
 
-    remove_qos_proc:
-        remove_proc_entry("qos", proc_gtp5g);
-    remove_urr_proc:
-        remove_proc_entry("urr", proc_gtp5g);
-    remove_qer_proc:
-        remove_proc_entry("qer", proc_gtp5g);
-    remove_far_proc:
-        remove_proc_entry("far", proc_gtp5g);
-    remove_pdr_proc:
-        remove_proc_entry("pdr", proc_gtp5g);
-    remove_dbg_proc:
-        remove_proc_entry("dbg", proc_gtp5g);
-    remove_gtp5g_proc:
-        remove_proc_entry("gtp5g", NULL);
+remove_qos_proc:
+    remove_proc_entry("qos", proc_gtp5g);
+remove_urr_proc:
+    remove_proc_entry("urr", proc_gtp5g);
+remove_qer_proc:
+    remove_proc_entry("qer", proc_gtp5g);
+remove_far_proc:
+    remove_proc_entry("far", proc_gtp5g);
+remove_pdr_proc:
+    remove_proc_entry("pdr", proc_gtp5g);
+remove_dbg_proc:
+    remove_proc_entry("dbg", proc_gtp5g);
+remove_gtp5g_proc:
+    remove_proc_entry("gtp5g", NULL);
     return -1;
 }
 
