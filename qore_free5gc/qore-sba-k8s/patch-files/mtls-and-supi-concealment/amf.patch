diff --git a/.netrc b/.netrc
index be78029..e0cb5aa 100644
--- a/.netrc
+++ b/.netrc
@@ -1,3 +1,3 @@
 # .netrc
 ## generate token with https://help.github.com/articles/creating-an-oauth-token-for-command-line-use
-machine github.com login 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
\ No newline at end of file
+machine github.com login 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
\ No newline at end of file
diff --git a/Application_entity/server/sbi/server.go b/Application_entity/server/sbi/server.go
index 7558de3..1a31d68 100644
--- a/Application_entity/server/sbi/server.go
+++ b/Application_entity/server/sbi/server.go
@@ -2,10 +2,15 @@ package sbi
 
 import (
 	"context"
+	"crypto/tls"
+	"crypto/x509"
+	"encoding/pem"
 	"fmt"
+	"io/ioutil"
 	"log"
 	"net/http"
 	"runtime/debug"
+	"strings"
 	"sync"
 	"time"
 
@@ -21,8 +26,8 @@ import (
 	"github.com/coranlabs/CORAN_AMF/Application_entity/pkg/app"
 	util_oauth "github.com/coranlabs/CORAN_AMF/Application_entity/server/util"
 	"github.com/coranlabs/CORAN_LIB_OPENAPI/models"
-	"github.com/coranlabs/CORAN_LIB_UTIL/httpwrapper"
 	logger_util "github.com/coranlabs/CORAN_LIB_UTIL/logger"
+	"github.com/lakshya-chopra/httpwrapper"
 )
 
 var (
@@ -45,6 +50,58 @@ type Server struct {
 	router     *gin.Engine
 }
 
+func PrintCertificateDetails(cert *x509.Certificate) {
+
+	sep := strings.Repeat("-", 15)
+
+	fmt.Printf("\n%s Server Certificate%s\n", sep, sep)
+
+	fmt.Printf("Subject: %s\n", cert.Subject)
+	fmt.Printf("Issuer: %s\n", cert.Issuer)
+	fmt.Printf("Serial Number: %s\n", cert.SerialNumber)
+	fmt.Printf("Not Before: %s\n", cert.NotBefore)
+	fmt.Printf("Not After: %s\n", cert.NotAfter)
+	fmt.Printf("Key Usage: %x\n", cert.KeyUsage)
+	fmt.Printf("Ext Key Usage: %v\n", cert.ExtKeyUsage)
+	fmt.Printf("DNS Names: %v\n", cert.DNSNames)
+	// fmt.Printf("Email Addresses: %v\n", cert.EmailAddresses)
+	fmt.Printf("IP Addresses: %v\n", cert.IPAddresses)
+	// fmt.Printf("URIs: %v\n", cert.URIs)
+	fmt.Printf("Signature Algorithm: %s\n", cert.SignatureAlgorithm)
+
+	fmt.Println("\nPEM Encoded Certificate:")
+	pemBlock := &pem.Block{
+		Type:  "CERTIFICATE",
+		Bytes: cert.Raw,
+	}
+	pemBytes := pem.EncodeToMemory(pemBlock)
+	fmt.Println(string(pemBytes))
+
+	fmt.Printf("%s End %s", sep, sep)
+}
+
+func ReadCertificate(filename string) (*x509.Certificate, error) {
+	// Read the certificate file
+	certPEM, err := ioutil.ReadFile(filename)
+	if err != nil {
+		return nil, fmt.Errorf("failed to read certificate file: %w", err)
+	}
+
+	// Decode the PEM block
+	block, _ := pem.Decode(certPEM)
+	if block == nil || block.Type != "CERTIFICATE" {
+		return nil, fmt.Errorf("failed to decode PEM block containing certificate")
+	}
+
+	// Parse the certificate
+	cert, err := x509.ParseCertificate(block.Bytes)
+	if err != nil {
+		return nil, fmt.Errorf("failed to parse certificate: %w", err)
+	}
+
+	return cert, nil
+}
+
 func NewServer(amf ServerAmf, tlsKeyLogPath string) (*Server, error) {
 	s := &Server{
 		ServerAmf: amf,
@@ -53,10 +110,24 @@ func NewServer(amf ServerAmf, tlsKeyLogPath string) (*Server, error) {
 	s.router = newRouter(s)
 
 	cfg := s.Config()
+
+	server_cert, err1 := tls.LoadX509KeyPair(cfg.GetCertPemPath(), cfg.GetCertKeyPath())
+
+	if err1 != nil {
+		log.Fatal(err1)
+	}
+
+	cert, err2 := ReadCertificate(cfg.GetCertPemPath())
+	if err2 != nil {
+		log.Fatal(err2)
+	} else {
+		PrintCertificateDetails(cert)
+	}
+
 	bindAddr := cfg.GetSbiBindingAddr()
 	logger.SBILog.Infof("Binding addr: [%s]", bindAddr)
 	var err error
-	if s.httpServer, err = httpwrapper.NewHttp2Server(bindAddr, tlsKeyLogPath, s.router); err != nil {
+	if s.httpServer, err = httpwrapper.NewHttp2Server(bindAddr, tlsKeyLogPath, s.router, server_cert); err != nil {
 		logger.InitLog.Errorf("Initialize HTTP server failed: %v", err)
 		return nil, err
 	}
@@ -171,9 +242,9 @@ func (s *Server) startServer(wg *sync.WaitGroup) {
 	if scheme == "http" {
 		err = s.httpServer.ListenAndServe()
 	} else if scheme == "https" {
+		fmt.Printf("using https")
 		err = s.httpServer.ListenAndServeTLS(
-			cfg.GetCertPemPath(),
-			cfg.GetCertKeyPath())
+			cfg.GetCertPemPath(), cfg.GetCertKeyPath())
 	} else {
 		err = fmt.Errorf("no support this scheme[%s]", scheme)
 	}
diff --git a/Dockerfile b/Dockerfile
index 3758c03..f228cdc 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -1,5 +1,5 @@
 # Stage 1: Build the Go amflication
-FROM golang:1.23.0-alpine AS builder
+FROM golang:1.23.0-bullseye AS builder
 
 # Set the working directory inside the container
 WORKDIR /amf
@@ -8,11 +8,45 @@ WORKDIR /amf
 COPY . /amf
 COPY .netrc /root/.netrc
 RUN ls -aL
-RUN apk add --no-cache git
+RUN apt install git wget 
+RUN apt update
+
 RUN go env -w GOPRIVATE=github.com/coranlabs
 # Download Go module dependencies
 RUN go mod download
 
+COPY go1.23.0.linux-amd64.tar.gz /tmp/
+
+RUN mkdir -p /go-1.23 && \
+    tar -C /go-1.23 -xzf /tmp/go1.23.0.linux-amd64.tar.gz && \
+    rm /tmp/go1.23.0.linux-amd64.tar.gz
+
+ENV GOROOT_BOOTSTRAP=/go-1.23/go
+
+
+RUN git clone https://github.com/lakshya-chopra/go /cloudflare-go
+#COPY cloudflare-go /cloudflare-go
+RUN rm -rf /usr/local/go/src/crypto
+RUN rm -rf /usr/local/go/src/vendor
+RUN cp /cloudflare-go/src/crypto -R /usr/local/go/src/crypto
+RUN cp /cloudflare-go/src/vendor -R /usr/local/go/src/vendor
+
+# RUN rm -rf /usr/local/go/src/
+# RUN cp /cloudflare-go/src/ -R /usr/local/go/src/
+WORKDIR /usr/local/go/src/
+
+# ENV GOROOT /usr/local/go
+RUN ./make.bash
+
+# ENV GOROOT /cloudflare-go 
+# ENV PATH $GOROOT/bin:$GOPATH/bin:$PATH
+# ENV go /cloudflare-go/bin/go
+
+# RUN /usr/local/go/bin/go
+RUN go version
+
+WORKDIR /amf
+
 # Build the Go amflication for Linux with CGO disabled
 # Adjust the path if your main.go is in the root directory
 RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -installsuffix cgo -o amf ./main.go
diff --git a/go.mod b/go.mod
index 4b0536d..b0df640 100644
--- a/go.mod
+++ b/go.mod
@@ -48,6 +48,7 @@ require (
 	github.com/json-iterator/go v1.1.12 // indirect
 	github.com/jtolds/gls v4.20.0+incompatible // indirect
 	github.com/klauspost/cpuid/v2 v2.2.7 // indirect
+	github.com/lakshya-chopra/httpwrapper v0.0.2
 	github.com/leodido/go-urn v1.4.0 // indirect
 	github.com/magiconair/properties v1.8.7 // indirect
 	github.com/mattn/go-isatty v0.0.20 // indirect
diff --git a/go.sum b/go.sum
index aaa960f..f2f32a7 100644
--- a/go.sum
+++ b/go.sum
@@ -78,6 +78,10 @@ github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
 github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
 github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
 github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
+github.com/lakshya-chopra/httpwrapper v0.0.1 h1:bnb2eYQBsYMX/gUr8uhSNxbjVfK/04EEozx9uA/gnqk=
+github.com/lakshya-chopra/httpwrapper v0.0.1/go.mod h1:zrgSmzr/IuUxKZAzaBELxyf3PgjhNn4gu8ppVbLr4OY=
+github.com/lakshya-chopra/httpwrapper v0.0.2 h1:dqxr1+kYGIHYmSbNnWDmJfHeTdKFZJloQJI7TYcRT9c=
+github.com/lakshya-chopra/httpwrapper v0.0.2/go.mod h1:zrgSmzr/IuUxKZAzaBELxyf3PgjhNn4gu8ppVbLr4OY=
 github.com/leodido/go-urn v1.4.0 h1:WT9HwE9SGECu3lg4d/dIA+jxlljEa1/ffXKmRjqdmIQ=
 github.com/leodido/go-urn v1.4.0/go.mod h1:bvxc+MVxLKB4z00jd1z+Dvzr47oO32F/QSNjSBOlFxI=
 github.com/magiconair/properties v1.8.7 h1:IeQXZAiQcpL9mgcAe1Nu6cX9LLw6ExEHKjN0VQdvPDY=
diff --git a/go1.23.0.linux-amd64.tar.gz b/go1.23.0.linux-amd64.tar.gz
new file mode 100644
index 0000000..61551ff
Binary files /dev/null and b/go1.23.0.linux-amd64.tar.gz differ
