/*
 * Nnwdaf_EventsSubscription
 *
 * Nnwdaf_EventsSubscription Service API.   Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved.
 *
 * API version: 1.2.0-alpha.7
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package events

// EventSubscription1 - Represents a subscription to a single event.
type EventSubscription1 struct {

	// FALSE represents not applicable for all slices. TRUE represents applicable for all slices.
	AnySlice bool `json:"anySlice,omitempty"`

	// Identification(s) of application to which the subscription applies.
	AppIds []string `json:"appIds,omitempty"`

	// Identification(s) of DNN to which the subscription applies.
	Dnns []string `json:"dnns,omitempty"`

	Dnais []string `json:"dnais,omitempty"`

	Event NwdafEvent `json:"event"`

	ExtraReportReq EventReportingRequirement1 `json:"extraReportReq,omitempty"`

	// Identification(s) of LADN DNN to indicate the LADN service area as the AOI.
	LadnDnns []string `json:"ladnDnns,omitempty"`

	// Indicates that the NWDAF shall report the corresponding network slice load level to the NF service consumer where the load level of the network slice identified by snssais is reached.
	LoadLevelThreshold int32 `json:"loadLevelThreshold,omitempty"`

	NotificationMethod NotificationMethod `json:"notificationMethod,omitempty"`

	MatchingDir MatchingDirection `json:"matchingDir,omitempty"`

	// Shall be supplied in order to start reporting when an average load level is reached.
	NfLoadLvlThds []ThresholdLevel1 `json:"nfLoadLvlThds,omitempty"`

	NfInstanceIds []string `json:"nfInstanceIds,omitempty"`

	NfSetIds []string `json:"nfSetIds,omitempty"`

	NfTypes []NfType `json:"nfTypes,omitempty"`

	NetworkArea NetworkAreaInfo `json:"networkArea,omitempty"`

	VisitedAreas []NetworkAreaInfo `json:"visitedAreas,omitempty"`

	// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
	MaxTopAppUlNbr int32 `json:"maxTopAppUlNbr,omitempty"`

	// Unsigned Integer, i.e. only value 0 and integers above 0 are permissible.
	MaxTopAppDlNbr int32 `json:"maxTopAppDlNbr,omitempty"`

	NsiIdInfos []NsiIdInfo1 `json:"nsiIdInfos,omitempty"`

	NsiLevelThrds []int32 `json:"nsiLevelThrds,omitempty"`

	QosRequ QosRequirement1 `json:"qosRequ,omitempty"`

	QosFlowRetThds []RetainabilityThreshold1 `json:"qosFlowRetThds,omitempty"`

	RanUeThrouThds []string `json:"ranUeThrouThds,omitempty"`

	// indicating a time in seconds.
	RepetitionPeriod int32 `json:"repetitionPeriod,omitempty"`

	// Identification(s) of network slice to which the subscription applies. It corresponds to snssais in the data model definition of 3GPP TS 29.520.
	Snssaia []Snssai `json:"snssaia,omitempty"`

	TgtUe TargetUeInformation1 `json:"tgtUe,omitempty"`

	CongThresholds []ThresholdLevel1 `json:"congThresholds,omitempty"`

	NwPerfRequs []NetworkPerfRequirement1 `json:"nwPerfRequs,omitempty"`

	BwRequs []BwRequirement1 `json:"bwRequs,omitempty"`

	ExcepRequs []Exception1 `json:"excepRequs,omitempty"`

	ExptAnaType ExpectedAnalyticsType `json:"exptAnaType,omitempty"`

	ExptUeBehav ExpectedUeBehaviourData `json:"exptUeBehav,omitempty"`

	RatTypes []RatType `json:"ratTypes,omitempty"`

	Freqs []int32 `json:"freqs,omitempty"`

	ListOfAnaSubsets []AnalyticsSubset `json:"listOfAnaSubsets,omitempty"`

	DisperReqs []DispersionRequirement1 `json:"disperReqs,omitempty"`

	RedTransReqs []RedundantTransmissionExpReq1 `json:"redTransReqs,omitempty"`

	WlanReqs []WlanPerformanceReq1 `json:"wlanReqs,omitempty"`

	// Identifies the UPF.
	UpfId string `json:"upfId,omitempty"`

	AppServerAddrs []AddrFqdn `json:"appServerAddrs,omitempty"`

	DnPerfReqs []DnPerformanceReq1 `json:"dnPerfReqs,omitempty"`
}

// AssertEventSubscription1Required checks if the required fields are not zero-ed
func AssertEventSubscription1Required(obj EventSubscription1) error {
	elements := map[string]interface{}{
		"event": obj.Event,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertNwdafEventRequired(obj.Event); err != nil {
		return err
	}
	if err := AssertEventReportingRequirement1Required(obj.ExtraReportReq); err != nil {
		return err
	}
	if err := AssertNotificationMethodRequired(obj.NotificationMethod); err != nil {
		return err
	}
	if err := AssertMatchingDirectionRequired(obj.MatchingDir); err != nil {
		return err
	}
	for _, el := range obj.NfLoadLvlThds {
		if err := AssertThresholdLevel1Required(el); err != nil {
			return err
		}
	}
	for _, el := range obj.NfTypes {
		if err := AssertNfTypeRequired(el); err != nil {
			return err
		}
	}
	if err := AssertNetworkAreaInfoRequired(obj.NetworkArea); err != nil {
		return err
	}
	for _, el := range obj.VisitedAreas {
		if err := AssertNetworkAreaInfoRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.NsiIdInfos {
		if err := AssertNsiIdInfo1Required(el); err != nil {
			return err
		}
	}
	if err := AssertQosRequirement1Required(obj.QosRequ); err != nil {
		return err
	}
	for _, el := range obj.QosFlowRetThds {
		if err := AssertRetainabilityThreshold1Required(el); err != nil {
			return err
		}
	}
	for _, el := range obj.Snssaia {
		if err := AssertSnssaiRequired(el); err != nil {
			return err
		}
	}
	if err := AssertTargetUeInformation1Required(obj.TgtUe); err != nil {
		return err
	}
	for _, el := range obj.CongThresholds {
		if err := AssertThresholdLevel1Required(el); err != nil {
			return err
		}
	}
	for _, el := range obj.NwPerfRequs {
		if err := AssertNetworkPerfRequirement1Required(el); err != nil {
			return err
		}
	}
	for _, el := range obj.BwRequs {
		if err := AssertBwRequirement1Required(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ExcepRequs {
		if err := AssertException1Required(el); err != nil {
			return err
		}
	}
	if err := AssertExpectedAnalyticsTypeRequired(obj.ExptAnaType); err != nil {
		return err
	}
	if err := AssertExpectedUeBehaviourDataRequired(obj.ExptUeBehav); err != nil {
		return err
	}
	for _, el := range obj.RatTypes {
		if err := AssertRatTypeRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.ListOfAnaSubsets {
		if err := AssertAnalyticsSubsetRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.DisperReqs {
		if err := AssertDispersionRequirement1Required(el); err != nil {
			return err
		}
	}
	for _, el := range obj.RedTransReqs {
		if err := AssertRedundantTransmissionExpReq1Required(el); err != nil {
			return err
		}
	}
	for _, el := range obj.WlanReqs {
		if err := AssertWlanPerformanceReq1Required(el); err != nil {
			return err
		}
	}
	for _, el := range obj.AppServerAddrs {
		if err := AssertAddrFqdnRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.DnPerfReqs {
		if err := AssertDnPerformanceReq1Required(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertRecurseEventSubscription1Required recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of EventSubscription1 (e.g. [][]EventSubscription1), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseEventSubscription1Required(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aEventSubscription1, ok := obj.(EventSubscription1)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertEventSubscription1Required(aEventSubscription1)
	})
}
