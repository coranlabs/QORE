/*
 * Nnwdaf_AnalyticsInfo
 *
 * Nnwdaf_AnalyticsInfo Service API.   Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved.
 *
 * API version: 1.2.0-alpha.6
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package analytics

import (
	"time"
)

// ContextElement - Contains context information corresponding with a specific context identifier.
type ContextElement struct {
	ContextId AnalyticsContextIdentifier `json:"contextId"`

	// Output analytics for the analytics subscription which have not yet been sent to the analytics consumer.
	PendAnalytics []EventNotification `json:"pendAnalytics,omitempty"`

	// Historical output analytics.
	HistAnalytics []EventNotification `json:"histAnalytics,omitempty"`

	// string with format 'date-time' as defined in OpenAPI.
	LastOutputTime time.Time `json:"lastOutputTime,omitempty"`

	// Information about analytics subscriptions that the NWDAF has with other NWDAFs to perform aggregation.
	AggrSubs []SpecificAnalyticsSubscription `json:"aggrSubs,omitempty"`

	// Historical data related to the analytics subscription.
	HistData []HistoricalData `json:"histData,omitempty"`

	// String uniquely identifying a NF instance. The format of the NF Instance ID shall be a  Universally Unique Identifier (UUID) version 4, as described in IETF RFC 4122.
	AdrfId string `json:"adrfId,omitempty"`

	// Type(s) of data stored in the ADRF by the NWDAF.
	AdrfDataTypes []AdrfDataType `json:"adrfDataTypes,omitempty"`

	// NWDAF identifiers of NWDAF instances used by the NWDAF service consumer when aggregating multiple analytics subscriptions.
	AggrNwdafIds []string `json:"aggrNwdafIds,omitempty"`

	// Identifiers of NWDAFs that provide ML models used by the NF service consumer.
	ModelProvIds []string `json:"modelProvIds,omitempty"`
}

// AssertContextElementRequired checks if the required fields are not zero-ed
func AssertContextElementRequired(obj ContextElement) error {
	elements := map[string]interface{}{
		"contextId": obj.ContextId,
	}
	for name, el := range elements {
		if isZero := IsZeroValue(el); isZero {
			return &RequiredError{Field: name}
		}
	}

	if err := AssertAnalyticsContextIdentifierRequired(obj.ContextId); err != nil {
		return err
	}
	for _, el := range obj.PendAnalytics {
		if err := AssertEventNotificationRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.HistAnalytics {
		if err := AssertEventNotificationRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.AggrSubs {
		if err := AssertSpecificAnalyticsSubscriptionRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.HistData {
		if err := AssertHistoricalDataRequired(el); err != nil {
			return err
		}
	}
	for _, el := range obj.AdrfDataTypes {
		if err := AssertAdrfDataTypeRequired(el); err != nil {
			return err
		}
	}
	return nil
}

// AssertRecurseContextElementRequired recursively checks if required fields are not zero-ed in a nested slice.
// Accepts only nested slice of ContextElement (e.g. [][]ContextElement), otherwise ErrTypeAssertionError is thrown.
func AssertRecurseContextElementRequired(objSlice interface{}) error {
	return AssertRecurseInterfaceRequired(objSlice, func(obj interface{}) error {
		aContextElement, ok := obj.(ContextElement)
		if !ok {
			return ErrTypeAssertionError
		}
		return AssertContextElementRequired(aContextElement)
	})
}
